## Ссылки, пути и адреса акторов
В этой главе описывается, как субъекты идентифицируются и находятся в пределах, возможно, распределенной системы акторов.
 Он связывает центральную идею о том, что `Actor Systems` формируют иерархии внутреннего контроля, а также то, что связь 
 между участниками прозрачна в отношении их размещения на нескольких сетевых узлах.
![alt text](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/images/ActorPath.png "ActorPath")

На приведенном выше рисунке показана взаимосвязь между наиболее важными объектами в системе акторов, пожалуйста, 
прочитайте подробнее.

### Что такое ссылка на актора?
Ссылка на актор является подтипом `ActorRef`, главной задачей которого является поддержка отправки сообщений актору, 
который он представляет. **Каждый актор имеет доступ к своей канонической (локальной) ссылке через `self` поле**; эта ссылка 
также включена в качестве ссылки отправителя по умолчанию для всех сообщений, отправленных другим участникам. И наоборот,
 во время обработки сообщения **актор имеет доступ к ссылке, представляющей отправителя текущего сообщения через метод `sender()`**.

Существует несколько различных типов ссылок на акторы, которые поддерживаются в зависимости от конфигурации системы акторов:

* Чисто локальные ссылки для акторов используются акторскими системами, которые не настроены на поддержку сетевых функций. 
Эти ссылки акторов не будут работать, если они отправляются через сетевое соединение с удаленной JVM;
* Ссылки локального актора при включении удаленного использования используются системами акторов, которые поддерживают 
сетевые функции для тех ссылок, которые представляют участников в пределах одной JVM. Для того, чтобы быть доступным 
при отправке на другие сетевые узлы, эти ссылки включают информацию о протоколе и удаленной адресации;
* Существует подтип ссылок локального актора, который используется для маршрутизаторов (т.е. акторов, подмешивающих в 
типаж `Router`). Его логическая структура такая же, как и для вышеупомянутых локальных ссылок, но отправка 
сообщения им отправляет их одному из своих детей непосредственно;
* Удаленные ссылки на акторы представляют собой акторов, которые достижимы с помощью удаленной связи, то есть отправка
 сообщений им будет прозрачно транслировать сообщения и отправлять их на удаленный JVM;
* Существует несколько специальных типов акторских ссылок, которые ведут себя как локальные ссылки акторов для всех 
практических целей:
   * `PromiseActorRef` - это особый вид `Promise` с целью завершения ответа от актора `akka.pattern.ask` 
   создает эту ссылку для актора;
   * `DeadLetterActorRef` - это стандартная реализация службы мертвых писем, к которой Akka маршрутизирует все сообщения,
    адресатов которых закрыты или отсутствуют;
   * `EmptyLocalActorRef` - это то, что Akka возвращает при поиске несуществующего пути локального актора: он 
   эквивалентен `DeadLetterActorRef`, но он сохраняет свой путь, чтобы Akka мог отправлять его по сети и сравнивать 
   его с другими существующими ссылками для этого пути, некоторые которые могли быть получены до смерти актора;
* Есть еще некоторые внутренние реализации, которые вы никогда не должны видеть:
   * Существует ссылка на актора, которая не является актором, но действует только как псевдо-супервизор для корневого 
   хранителя, мы называем это «тем, кто ходит по пузырям пространства-времени»;
   * Первая служба регистрации началась до фактического запуска объектов создания акторов - это поддельная акторская 
   ссылка, которая принимает события журнала и печатает их непосредственно на стандартный вывод; это `Logging.StandardOutLogger`.
 
### Что такое акторский путь?
Поскольку акторы создаются строго иерархически, существует уникальная последовательность имен акторов, определяемая 
рекурсивно после связей надзора между дочерним и родительским до корня системы акторов. Эта последовательность может 
рассматриваться как папки в файловой системе, поэтому мы использовали имя «путь», чтобы ссылаться на нее, 
хотя иерархия акторов имеет фундаментальное отличие от иерархии файловой системы.

Путь актора состоит из якоря, который идентифицирует систему акторов, за которой следует конкатенация элементов пути от 
корневого опекуна к назначенному игроку; элементы пути - это имена перемещаемых участников и разделены косой чертой.

#### В чем разница между ссылкой актора и путём?
Ссылка на актора обозначает одного актора, а жизненный цикл ссылки соответствует жизненному циклу актора; путь актора 
представляет собой имя, которое может или не может быть заселено актором, и сам путь не имеет жизненного цикла, он никогда 
не становится недействительным. Вы можете создать путь к актору без создания актора, но вы не можете создать ссылку на 
актора без создания соответствующего актора.

Вы можете создать актора, закончить его, а затем создать нового актора с одним и тем же путем. Недавно созданный актор - 
новое воплощение актора. Это не тот же самый актор. Ссылка актора на старое воплощение недействительна для нового воплощения.
 Сообщения, отправленные на ссылку старого актора, не будут доставлены в новое воплощение, даже если они имеют один и тот же путь.

#### Анкор для акторов
 Каждый путь актора имеет адресную составляющую, описывающую протокол и местоположение, с помощью которого соответствующий
  субъект доступен, а затем имена участников в иерархии от корня вверх. Пример:
  
```scala
    "akka://my-sys/user/service-a/worker1"                   // purely local
    "akka.tcp://my-sys@host.example.com:5678/user/service-b" // remote
```

Здесь `akka.tcp` является удаленным транспортом по умолчанию для выпуска 2.4; другие транспорты могут быть подключены. 
Интерпретация части хоста и порта (то есть `host.example.com:5678` в примере) зависит от используемого механизма 
транспорта, но она должна соблюдать структурные правила URI.

#### Логические пути актора
Уникальный путь, полученный путем слежения за родительским контролем над корневым опекуном, называется логическим путем. 
Этот путь точно соответствует созданию "родословной" актора, поэтому он полностью детерминирован, как только настроена удаленная 
конфигурация системы актора (а вместе с ней и адресная составляющая пути).

#### Физические пути актора
В то время как путь логического актора описывает функциональное местоположение в пределах одной действующей системы, 
дистанционное развертывание на основе конфигурации означает, что актор может быть создан на другом сетевом узле, чем его 
родительский элемент, то есть в другой системе акторов. В этом случае, следуя пути актора от корневого опекуна, влечет 
за собой пересечение сети, что является дорогостоящей операцией. Поэтому **каждый актор имеет физический путь**, 
начиная с корневого хранителя акторской системы, где находится фактический объект актора. Использование этого пути в 
качестве ссылки отправителя при запросе других участников позволит им напрямую ответить на этот актор, минимизируя 
задержки, вызванные маршрутизацией.

Важным аспектом является то, что путь физического актора никогда не охватывает несколько акторских систем или JVM. 
Это означает, что логический путь (иерархия наблюдения) и физический путь (акторское развертывание) актора могут 
расходиться, если один из его предков удаленно контролируется.

#### Идентификатор пути актора или символическая ссылка?
Как и в некоторых реальных файловых системах, вы можете подумать о «псевдониме пути» или «символической ссылке» для 
актора, то есть один актор может быть доступен с использованием нескольких путей. Однако следует отметить, что иерархия 
акторов отличается от иерархии файловой системы. **Вы не можете свободно создавать акторские пути**, такие как символические 
ссылки, для обозначения произвольных участников. Как описано в приведенных выше разделах логического и физического 
акторского пути, **путь актора должен быть либо логическим путем, который представляет собой иерархию наблюдения, либо 
физический путь**, который представляет развертывание актора.

### Как получить ссылки на Акторов?
Существуют две общие категории, на основе которых можно получить ссылки на акторы: **создавая акторов** или **просматривая** их, 
где последняя функциональность входит в два варианта создания ссылок актора из конкретных путей актора и запроса 
иерархии логического актора.

#### Создание акторов
Акторскую систему обычно запускают, создавая акторов под опекуном-опекуном, используя метод `ActorSystem.actorOf`, а 
затем используя `ActorContext.actorOf` из созданных участников, чтобы создать дерево акторов. Эти методы возвращают 
ссылку на вновь созданного актора. Каждый актор имеет прямой доступ (через свой `ActorContext`) к ссылкам для своего 
родителя, самого себя и своих детей. Эти ссылки могут быть отправлены в сообщениях другим субъектам, что позволяет им 
отвечать напрямую.

#### Поиск акторов по конкретному пути
Кроме того, ссылки на акторы могут быть просмотрены с использованием метода `ActorSystem.actorSelection`. Выбор может 
использоваться для связи с указанным актором, и актор, соответствующий выбору, просматривается при доставке каждого сообщения.

Чтобы приобрести `ActorRef`, привязанный к жизненному циклу конкретного актора, вам нужно отправить сообщение, например, 
встроенное сообщение `Identify`, актору и использовать ссылку `sender()` ответа от актора.

#### Абсолютный или Относительный путь?
В дополнение к `ActorSystem.actorSelection` есть также `ActorContext.actorSelection`, который доступен внутри любого 
актора как `context.actorSelection`. Это дает выбор актора, как его близнец на `ActorSystem`, но вместо того, чтобы 
искать путь, начинающийся с корня дерева акторов, он начинается с текущего актора. **Элементы пути, состоящие из двух 
точек («**`..`**»), могут использоваться для доступа к родительскому актору**. Например, вы можете отправить сообщение 
определенному родственнику:

```scala
    context.actorSelection("../brother") ! msg
```
Абсолютные пути также могут быть просмотрены контекстом обычным способом, т. е.
```scala
    context.actorSelection("/user/serviceA") ! msg
```
будет работать должным образом.

#### Запрос иерархии логического актора
Поскольку система-актор образует файловую систему, такую как иерархия, сопоставление по путям возможно так же, как 
поддерживается оболочками Unix: вы можете заменить (части) имена элементов пути с помощью подстановочных знаков 
(`*` и `?`) сформулировать выбор, который может соответствовать нулю или более фактическим акторам. Поскольку 
результат не является ссылкой на одного актора, он имеет другой тип `ActorSelection` и не поддерживает полный набор 
операций, которые делает `ActorRef`. Выбор может быть сформулирован с использованием методов `ActorSystem.actorSelection` и 
`ActorContext.actorSelection` и поддерживает отправку сообщений:

```scala
    context.actorSelection("../*") ! msg
```

отправит `msg` всем братьям и сестрам, включая текущего актора. Что касается ссылок, полученных с использованием 
`actorSelection`, для выполнения отправки сообщения выполняется обход иерархии наблюдения. Поскольку точный набор 
участников, которые соответствуют выбору, может измениться, даже когда сообщение направляется к получателям, невозможно 
просмотреть выбор для изменения оживления. Чтобы это сделать, устраните неопределенность, отправив запрос и собрав все ответы, 
извлекая ссылки отправителя, а затем просмотрите все обнаруженные конкретные участники. Эта схема разрешения выбора 
может быть улучшена в будущем выпуске.

>Основная информация: `actorOf` vs. `actorSelection`
* `actorOf` только когда-либо создает нового актора и создает его как прямой дочерний элемент контекста, на который 
вызывается этот метод (который может быть любой акторской или акторской системой);
* `actorSelection` только когда-либо просматривает существующих участников при доставке сообщений, т.е. не создает 
участников или проверяет существование участников при создании выбора.

### Ссылка на актора и равенство путей
Равенство `ActorRef` соответствует намерению, что `ActorRef` соответствует воплощению целевого актора. **Сравнение двух ссылок 
акторов эквивалентно, когда они имеют один и тот же путь и указывают на одно и то же воплощение актора. Ссылка, указывающая
 на завершенного актора, не эквивалентна ссылке, указывающей на другого (воссозданного) актора с тем же путем**. 
 Обратите внимание, что перезапуск актора, вызванный сбоем, по-прежнему означает, что он является одним и тем же 
 акторским воплощением, то есть перезапуск не отображается для потребителя `ActorRef`.

Если вам нужно отслеживать ссылки акторов в коллекции и не заботьтесь о том, чтобы воплотить актор, вы можете 
использовать `ActorPath` как ключ, потому что идентификатор целевого актора не учитывается при сравнении путей актора.

### Повторное использование пути актора
**Когда актор прекращается, его ссылка укажет на почтовый ящик мертвых писем, `DeathWatch`** опубликует его окончательный 
переход и, как правило, он не оживет _(так как жизненный цикл актора не позволяет этого)_. В то время 
как можно создать актора в более позднее время с идентичным путем - из-за того, что невозможно обеспечить противоположное,
 не сохраняя при этом набор всех участников, когда-либо созданных, - это не очень хорошая практика: сообщения, 
 отправленные с `actorSelection` актору который «умер» внезапно начинает работать снова, но без какой-либо гарантии 
 порядка между этим переходом и любым другим событием, следовательно, новый житель пути может получать сообщения, 
 предназначенные для предыдущего арендатора.

Это может быть правильная вещь в особых обстоятельствах, но обязательно ограничьте ее обработку именно руководителем 
актора, потому что это единственный актор, который может надежно обнаруживать правильную дерегистрацию имени, перед 
которым создание нового ребенок будет терпеть неудачу.

Он также может потребоваться во время тестирования, когда испытуемый зависит от того, создается ли он на определенном 
пути. В этом случае лучше всего высмеять своего супервизора, чтобы он пересылал сообщение `Terminated` в соответствующую 
точку в тестовой процедуре, позволяя последнему дождаться надлежащей дерегистрации имени.

### Взаимодействие с удаленным развертыванием
Когда актор создает ребенка, разработчик системы акторской системы будет решать, находится ли новый актор в одной 
JVM или на другом узле. Во втором случае создание актора будет инициировано через сетевое соединение, которое произойдет
 в другой JVM и, следовательно, в другой системе акторов. Удаленная система поместит нового актора под особый путь, 
 зарезервированный для этой цели, и супервизор нового актора будет удаленной ссылкой на актора (представляющий того 
 актора, который вызвал его создание). В этом случае `context.parent` (ссылка супервизора) и `context.path.parent` 
 (родительский узел на пути актора) не представляют одного и того же актора. Однако поиск имени ребенка в супервизоре 
 будет найти его на удаленном узле, сохраняя логическую структуру, например. при отправке на неразрешенный справочник актора.

![alt text](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/images/RemoteDeployment.png "RemoteDeployment")

### Для чего используется адресная часть?
При отправке ссылки актора по сети он представлен его путем. Следовательно, путь должен полностью кодировать всю 
информацию, необходимую для отправки сообщений основному игроку. Это достигается путем кодирования протокола, хоста и 
порта в адресной части строки пути. Когда актор-система получает акторский путь от удаленного узла, он проверяет, 
совпадает ли адрес этого пути с адресом этой системы акторов, и в этом случае он будет разрешен для локальной ссылки 
актора. В противном случае он будет представлен ссылкой удаленного актора.

### Видимость путей акторов верхнего уровня
В корне иерархии пути находится корневой опекун, над которым найдены все остальные акторы; его имя "`/`". Следующий 
уровень состоит из следующего:

* **`/user`** является опекуном-актором для всех созданных пользователем игроков верхнего уровня; ниже, чем те, которые 
созданы с помощью `ActorSystem.actorOf`;
* **`/system`** является опекуном-актором для всех созданных системой исполнителей верхнего уровня, например. прослушивание 
слушателей или участников, автоматически развернутых по конфигурации в начале системы акторов;
* **`/deadLetters`** - это агент мертвых писем, в котором все сообщения, отправленные остановленным или несуществующим 
субъектам, перенаправляются (с максимальной эффективностью: сообщения могут быть потеряны даже в пределах локальной JVM);
* **`/temp`** является хранителем для всех недолговечных созданных системой объектов, например. те, которые используются 
при реализации `ActorRef.ask`;
* **`/remote`** - это искусственный путь, ниже которого находятся все действующие лица, руководители которых являются 
удаленными ссылками на акторов.

Необходимость структурирования пространства имен для таких акторов возникает из-за центральной и очень простой цели 
дизайна: все в иерархии является актором, и все действующие лица действуют одинаково. Следовательно, вы можете не только
 искать созданных вами акторов, но и искать системного опекуна и посылать ему сообщение (которое в этом случае он 
 будет отслушать). Этот мощный принцип означает, что нет никаких причуд для запоминания, что делает всю систему более 
 однородной и последовательной.

[=> далее: Прозрачность местоположения](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/readmes/concepts/location-transparency.md)

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/akka/blob/akka_starter/readme.md)