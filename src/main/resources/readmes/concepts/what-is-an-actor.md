## Что такое актор?

В предыдущем разделе о [системе акторов](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/readmes/concepts/actor-systems.md) 
объяснялось, как субъекты формируют иерархии и являются наименьшей единицей при создании приложения. В этом разделе 
рассматривается один такой актор изолированно, объясняя понятия, с которыми вы сталкиваетесь при его реализации. 

Актор является контейнером для сотояния (State), поведения (Behavior), почтового ящика (Mailbox), дочерних акторов (Child Actors)
 и стратегии супервизора (Supervisor Strategy). Все это инкапсулировано за ссылкой на актора. Одним из примечательных 
 аспектов является то, что у участников есть явный жизненный цикл, они не автоматически уничтожаются, когда больше не 
 ссылаются; после того, как вы создали его, ваша ответственность состоит в том, чтобы убедиться, что он в конечном итоге 
 также будет прекращен, что также дает вам возможность контролировать, как освобождаются ресурсы. Когда актор завершается.

### Ссылка для акторов
Как подробно описано ниже, объект актора должен быть экранирован снаружи, чтобы извлечь выгоду из модели актора. 
Поэтому субъекты представлены снаружи с использованием ссылок на акторов, которые являются объектами, которые могут 
свободно передаваться и без ограничений. Это разделение на внутренний и внешний объект обеспечивает прозрачность для 
всех желаемых операций: перезапуск актора без необходимости обновления ссылок в другом месте, размещение фактического 
объекта актора на удаленных хостах, отправка сообщений акторам в совершенно разных приложениях. Но самый важный аспект 
заключается в том, что **невозможно заглянуть внутрь актора и завладеть его состоянием извне**, если актор не собирается
 публиковать эту информацию сам.

### Сотояние (State)
Объекты актора обычно содержат некоторые переменные, которые отражают возможные состояния, в которых может находиться 
актор. Это может быть явный конечный автомат (например, с использованием модуля [FSM](https://doc.akka.io/docs/akka/current/fsm.html),
 или он может быть счетчиком, множеством слушателей, ожидающими запросов и т.д. Эти данные делают актора ценным, и 
 они должны быть защищены от коррупции другими акторами. Хорошей новостью является то, что акторы концептуально имеют 
 свою собственную легкую нить, которая полностью защищена от остальной системы. Это означает, что вместо того, чтобы 
 синхронизировать доступ с помощью блокировок, вы можете написать свой код актора, не беспокоясь о параллелизме вообще.

За кулисами Akka будет запускать наборы акторов на наборах реальных потоков, где обычно многие участники разделяют один
 поток, а последующие вызовы одного актора могут в конечном итоге обрабатываться на разных потоках. Akka гарантирует, 
 что эта деталь реализации не влияет на однопоточность обработки состояния актора.

Поскольку внутреннее состояние имеет жизненно важное значение для действий актора, наличие несогласованного состояния 
является фатальным. Таким образом, когда актор терпит неудачу и перезапускается его супервизором, состояние будет создано
 с нуля, как при первом создании актора. Это должно позволить возможность самовосстановления системы.

При желании, состояние актора может автоматически восстанавливаться до состояния до перезапуска, сохраняя полученные 
сообщения и воспроизводя их после перезапуска.

### Поведение (Behavior)
Каждый раз, когда сообщение обрабатывается, оно сопоставляется с текущим поведением актора. Поведение означает функцию, 
которая определяет действия, которые должны быть предприняты в ответ на сообщение в этот момент времени, например, 
пересылать запрос, если клиент авторизован, отрицать это иначе. Такое поведение может меняться со временем, например,
 потому что разные клиенты получают авторизацию с течением времени или потому, что актор может перейти в режим 
 «без обслуживания» и позже вернуться. Эти изменения достигаются путем кодирования их в переменных состояния, которые 
 считываются из логики поведения, или сама функция может быть заменена во время выполнения, см. операции `become` 
 и `unbecome`. Однако начальное поведение, определенное при построении объекта-актора, является особенным в том смысле, 
 что перезапуск актора сбросит его поведение на этот начальный.

### Почтовый ящик (Mailbox)
Цель актора - обработка сообщений, и эти сообщения были отправлены актору от других участников (или из-за пределов 
акторской системы). Элемент, который соединяет отправителя и получателя, - это почтовый ящик актора: каждый актор 
имеет ровно один почтовый ящик, на который все отправители помещают свои сообщения. Запуск происходит во временном 
порядке операций отправки, что означает, что сообщения, отправленные от разных участников, могут не иметь определенного 
порядка во время выполнения из-за кажущейся случайности распространения участников по потокам. С другой стороны, отправка 
нескольких сообщений одной и той же цели от одного и того же актора приведет их в очередь в том же порядке.

Существуют разные варианты реализации почтовых ящиков, по умолчанию это `FIFO`: порядок сообщений, обрабатываемых актором, 
соответствует порядку, в котором они были установлены в очередь. Обычно это хороший дефолт, но приложениям может 
потребоваться приоритизировать некоторые сообщения по сравнению с другими. В этом случае почтовый ящик приоритета будет 
помещаться не всегда в конце, а в позицию, заданную приоритетом сообщения, который может быть даже спереди. При 
использовании такой очереди порядок обработанных сообщений будет, естественно, определяться алгоритмом очереди и вообще 
не быть FIFO.

Важная особенность, в которой Akka отличается от некоторых других реализаций модели актора, заключается в том, что 
текущее поведение всегда должно обрабатывать следующее сообщение, но не сканирует почтовый ящик для следующего 
сопоставления. Отказ от обработки сообщения обычно рассматривается как сбой, если это поведение не будет отменено.

### Дочерние акторы
Каждый актор потенциально является супервизором: если он создает дочерние объекты для делегирования подзадач, он 
автоматически контролирует их. Список детей поддерживается в контексте актора, и у него есть доступ к нему. Изменения 
в списке выполняются путем создания (`context.actorOf(...)`) или остановки (`context.stop(child)`) детей, и эти действия 
немедленно отражаются. Фактические действия по созданию и завершению происходят за кулисами асинхронным образом, поэтому 
они не блокируют свой супервизор.

### Стратегия наблюдателя (Supervisor Strategy)
Последней частью актора является его стратегия обработки ошибок своих детей. Управление ошибками затем выполняется 
Akka прозрачно, применяя одну из стратегий, описанных в [Наблюдение и мониторинг](https://doc.akka.io/docs/akka/current/general/supervision.html)
 для каждого входящего сбоя. Поскольку эта стратегия имеет основополагающее значение для структуры актора, она не 
 может быть изменена после создания актора.

Учитывая, что для каждого актора существует только одна такая стратегия, это означает, что если разные стратегии 
применяются к различным детям актора, дети должны быть сгруппированы под промежуточными руководителями с соответствующими 
стратегиями, предпочитая еще раз структурировать акторские системы в соответствии с разделение задач на подзадачи.

### Когда актор завершается
После прекращения действия актора, т.е. сбоя, который не обрабатывается перезагрузкой, он останавливается или 
останавливается своим супервизором, он освобождает свои ресурсы, выгружая все остальные сообщения из своего почтового 
ящика в «почтовый ящик мертвых писем», который отправит их в `EventStream` как `DeadLetters`. Почтовый ящик затем 
заменяется ссылкой на акторский системный почтовый ящик, перенаправляя все новые сообщения в `EventStream` как `DeadLetters`. 
Однако, поэтому не полагайтесь на это, чтобы построить «гарантированную доставку».

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/akka/blob/akka_starter/readme.md)