## Надежность доставки сообщений

Akka помогает вам создавать надежные приложения, которые используют несколько процессорных ядер на одном компьютере 
(`scaling up`) или распределяются по компьютерной сети (`scaling out`). Ключевая абстракция для этой работы заключается 
в том, что все взаимодействия между вашими кодовыми единицами-субъектами происходят через передачу сообщений, поэтому 
точная семантика передачи сообщений между участниками заслуживает их собственной главы.

Рассмотрите приложение, которое охватывает несколько сетевых хостов. 
Основной механизм связи - это то же самое: отправка актору на локальную JVM или удаленному игроку, но будут наблюдаемые 
различия в задержке доставки (возможно, также в зависимости от пропускной способности сетевой ссылки и размера сообщения)
 и надежность. В случае отправки удаленного сообщения есть еще несколько шагов, которые означают, что больше может пойти
  не так. Другим аспектом является то, что локальная передача будет передавать ссылку на сообщение внутри одной JVM без
   каких-либо ограничений на отправку базового объекта, тогда как удаленный транспорт будет устанавливать ограничение
    на размер сообщения.

Написание ваших акторов, чтобы каждое взаимодействие могло быть отдаленным, - это безопасная, пессимистическая ставка. 
Это означает только полагаться на те свойства, которые всегда гарантированы и которые подробно обсуждаются ниже. У этого
 есть некоторые накладные расходы в реализации актора. Если вы готовы пожертвовать полной прозрачностью местоположения,
  например, в случае группы тесно сотрудничающих акторов, вы можете разместить их всегда на одной JVM и пользоваться 
  более строгими гарантиями доставки сообщений. Подробности этого компромисса обсуждаются ниже.

### Общие правила
Это правила отправки сообщений (т.е. метод **`tell`** или **`!`**, который также лежит в основе шаблона запроса):

* доставка **не более одного раза** (`at-most-once`), то есть без гарантированной доставки;
* **упорядочение сообщений по паре отправитель-получатель**

Первое правило обычно встречается и в других реализациях акторов, а второе - для Akka.

#### Что означает `at-most-once`?

Когда дело доходит до описания семантики механизма доставки, существуют три основные категории:

* **`at-most-once`** доставка означает, что для каждого сообщения, переданного механизму, это сообщение доставляется один 
раз или не доставляется ни разу; в более случайных выражениях это означает, что **сообщения могут быть потеряны**;
* **`at-least-once`** доставка означает, что для каждого сообщения, переданного механизму, потенциально много попыток при 
его доставке, так что по меньшей мере один преуспевает; опять же, в более случайных выражениях это означает, что 
**сообщения могут быть дублированы, но не потеряны**;
* **`exactly-once`** доставка означает, что для каждого сообщения, переданного механизму, ровно одна доставка производится 
получателю; **сообщение не может быть потеряно и не дублировано**.

**Первая** из них - самая дешевая - наивысшая производительность, наименьшая накладная реализация - потому что ее можно 
выполнить с помощью режима «огонь и затухание», не сохраняя состояние на отправляющем конце или в транспортном механизме.
 
**Вторая** требует повторных попыток для противодействия транспортным потерям, что означает сохранение состояния на 
 отправляющем конце и наличие механизма подтверждения на принимающей стороне. 

**Третяя** - самая дорогая - и, 
 следовательно, худшая производительность, потому что в дополнение к второму он требует сохранения состояния на принимающей
  стороне, чтобы отфильтровать дублированные поставки.

#### Почему нет гарантированной доставки?

В основе проблемы лежит вопрос, что именно эта гарантия означает:

1. Сообщение отправляется в сети?
2. Сообщение получено другим хостом?
3. Сообщение помещается в почтовый ящик целевого участника?
4. Сообщение начинает обрабатываться целевым игроком?
5. Сообщение успешно обработано целевым игроком?

Каждый из них имеет разные проблемы и затраты, и очевидно, что существуют условия, при которых любая библиотека передачи
 сообщений не сможет выполнить; например, о настраиваемых типах почтовых ящиков и о том, как ограниченный почтовый ящик
  будет взаимодействовать с третьим пунктом, или даже о том, что он хотел бы принять решение о «успешной» части пятой.

Единственным значимым способом для отправителя **узнать, было ли успешное взаимодействие**, является получение сообщения о 
подтверждении бизнес-уровня, которое не является чем-то, что Акка не может сделать сама по себе. Akka охватывает распределенные
 вычисления и делает ошибку связи явной через передачу сообщений, поэтому она не пытается 
лгать и эмулировать неаккуратную абстракцию. Это модель, которая с успехом использовалась в Erlang и требует от 
пользователей разработки своих приложений вокруг нее. 

Еще один поворот в этом вопросе заключается в том, что, предоставляя только основные гарантии, те, которые используют 
случаи, которые не нуждаются в большей надежности, не оплачивают затраты на их реализацию; всегда можно добавить более 
высокую надежность поверх базовых, но ретроэффективно не удалять надежность, чтобы повысить производительность.

#### Порядок сообщений
Для данной пары акторов, сообщения, отправленные непосредственно от первого ко второму, не будут получены вне порядка.
Эта гарантия применяется только при отправке с оператором `tell` в конечный пункт назначения, а не при использовании
 посредников или других средств распространения сообщений.

Гарантия иллюстрируется следующим:

```text
Актор `A1` посылает сообщения `M1, M2, M3` для `A2`

Актор `A3` посылает сообщения `M4, M5, M6` для `A2`
```

1. Если `M1` доставлен, он должен быть доставлен до `M2` и `M3`;
2. Если `M2` доставлен, он должен быть доставлен до `M3`;
3. Если `M4` доставлен, он должен быть доставлен до `M5` и `M6`;
4. Если `M5` доставлен, он должен быть доставлен до `M6`;
5. A2 может видеть сообщения из A1, чередующиеся с сообщениями `A3`;
6. Поскольку нет гарантированной доставки, любое из сообщений может быть отброшено, то есть не достигнет `A2`.

> Важно отметить, что гарантия Akka применяется к порядку, в котором сообщения помещаются в почтовый ящик получателя. 
Если реализация почтового ящика не соответствует порядку FIFO (например, `PriorityMailbox`), тогда порядок обработки актором
 может отличаться от порядка очередности.

Обратите внимание, что это правило **не является переходным**:

* Актор `A` отправляет сообщение `M1` актору `C`
* Актор `А` затем отправляет сообщение `M2` актору `B`
* Актор `B` передает сообщение `M2` актору `C`
* Актор `C` может принимать `M1` и `M2` в любом порядке

Причинное транзитивное упорядочение означало бы, что `M2` никогда не принимается до `M1` у актора `C` (хотя любой из них
 может быть потерян). Это упорядочение может быть нарушено из-за различных задержек доставки сообщений, когда `A`, `B` и `C` 
 находятся на разных сетевых узлах.
 
 >Создание актора рассматривается как сообщение, отправленное от родителя к ребенку, с той же семантикой, о которой 
 говорилось выше. Отправка сообщения актору способом, который может быть переупорядочен с помощью этого первоначального
  сообщения о создании, означает, что сообщение может не прибыть, потому что актор еще не существует. Пример, когда
   сообщение может появиться слишком рано, состояло бы в создании агента `R1` с дистанционным развертыванием, отправке
    его ссылки на другой удаленный актор `R2` и `R2 `отправить сообщение `R1`. Примером четко определенного порядка 
    является родитель, который создает актора и немедленно отправляет ему сообщение.
    
#### Связь отказа
Обратите внимание, что описанные выше гарантии заказа сохраняются только для пользовательских сообщений между участниками.
 Отказ ребенка от актора сообщается специальными системными сообщениями, которые не упорядочены относительно обычных 
 пользовательских сообщений. Особенно:

* дочерний актор `C` отправляет сообщение `M` своему родительскому `P`;
* ребенок не справляется с неудачей `F`;
* родительский актор `P` может получать два события либо в порядке `M`, `F` или `F`, `M`.

Причиной этого является то, что внутренние системные сообщения имеют свои собственные почтовые ящики, поэтому упорядочение
 вызовов очереди пользователя и системных сообщений не может гарантировать порядок их времени декомпрессии.

### Правила отправки сообщений в JVM (локальном)
#### Будьте осторожны, что вы делаете с этим разделом!
Опираясь на более высокую надежность в этом разделе, не рекомендуется, так как он привяжет ваше приложение к локальному
 развертыванию: приложение, возможно, придется разрабатывать по-разному (вместо того, чтобы просто использовать некоторые
  шаблоны обмена сообщениями локально для некоторых участников), чтобы быть подходящим для работы на кластере машин. 
  Наше кредо - «дизайн один раз, развертывайте по своему усмотрению», и для достижения этого вы должны полагаться
   только на Общие правила.

#### Надежность отправки местных сообщений
Набор тестов Akka основан на том, чтобы не потерять сообщения в локальном контексте (а также для тестов условий без 
ошибок и для удаленного развертывания), что означает, что мы на самом деле прилагаем все усилия, чтобы наши тесты были
 стабильными. Однако локальная операция проверки может завершиться по тем же причинам, что и обычный вызов метода на JVM:

* StackOverflowError
* OutOfMemoryError
* другой VirtualMachineError

Кроме того, локальные отправления могут не соответствовать специальным образом Akka:

* если почтовый ящик не принимает сообщение (например, полный BoundedMailbox)
* если принимающий актор терпит неудачу при обработке сообщения или уже завершен

В то время как первый вопрос конфигурации, второй заслуживает некоторой мысли: отправитель сообщения не получает 
обратной связи, если во время обработки было исключение, это уведомление отправляется супервизору. Это вообще не отличает
 от потерянного сообщения для внешнего наблюдателя.

### Заказ отправки местных сообщений
Предполагая строгие почтовые ящики FIFO, вышеупомянутое предостережение о непереходности гарантии заказа сообщений
 устраняется при определенных условиях. Как вы заметите, они довольно тонкие, поскольку это стоит, и даже 
  что будущие оптимизации производительности аннулируют весь этот абзац. Возможно, неисчерпывающий список противопоказаний:

* Прежде чем получить первый ответ от актора верхнего уровня, существует блокировка, которая защищает внутреннюю 
промежуточную очередь, и эта блокировка несправедлива; подразумевается, что запросы очереди от разных отправителей, 
которые поступают во время создания актора (в деталях, детали более активно), могут быть переупорядочены в зависимости 
от низкоуровневого планирования потоков. Поскольку на JVM не существует вполне справедливых замков, это невозможно;
* Тот же механизм используется при построении маршрутизатора, а точнее, маршрутизированного ActorRef, поэтому такая же
 проблема существует для участников, развернутых с помощью маршрутизаторов;
* Как упоминалось выше, проблема возникает везде, где блокировка задействована во время enqueueing, которая также может
 применяться к пользовательским почтовым ящикам.

Этот список был составлен тщательно, но другие проблемные сценарии, возможно, ускользнули от нашего анализа.

#### Как локальный порядок относится к сетевому порядку
Правило о том, что для данной пары участников сообщения, отправленные непосредственно от первого ко второму, не будут
 получены недействительными для сообщений, отправляемых по сети с использованием протокола TCP на основе протокола Akka.

Как объяснялось в предыдущем разделе, локальное сообщение отправляет подчиненное транзитивное каузальное упорядочение
 при определенных условиях. Это упорядочение может быть нарушено из-за разных задержек доставки сообщений. Например:

* Актор А на узле-1 отправляет сообщение M1 актору C на узел-3
* Актор A на узле-1 затем отправляет сообщение M2 актору B на узле-2
* Актор B на узле-2 передает сообщение M2 актору C на узел-3
* Актор C может принимать M1 и M2 в любом порядке

Для M1 может потребоваться больше времени, чтобы «перемещаться» к узлу-3, чем требуется, чтобы M2 «перемещался» к узлу-3
 через узел-2.

### Абстракции более высокого уровня
Основанный на небольшом и последовательном инструменте, установленном в ядре Akka, Akka также предоставляет мощные 
абстракции более высокого уровня поверх него.

#### Шаблоны обмена сообщениями
Как обсуждалось выше, прямой ответ на требование надежной доставки является явным протоколом ACK-RETRY. В простейшей
 форме это требует

* способ идентифицировать отдельные сообщения для корреляции сообщения с подтверждением
* механизм повтора, который будет повторно отправлять сообщения, если не будет подтвержден вовремя
* способ для приемника обнаруживать и удалять дубликаты

Третий становится необходимым в силу того, что подтверждения не гарантируются. Протокол ACK-RETRY с подтверждениями на
 уровне бизнеса поддерживается по крайней мере доставкой модуля Accka Persistence. Дубликаты могут быть обнаружены путем
  отслеживания идентификаторов сообщений, отправленных по минимальной доставке. Другой способ реализации третьей части
   - сделать обработку идемпотентных сообщений на уровне бизнес-логики.

#### Поиск Событий (Event Sourcing)
Событие sourcing (и sharding) - это то, что делает крупные веб-сайты масштабируемыми для миллиардов пользователей,
 и идея довольно проста: когда компонент (think actor) обрабатывает команду, он генерирует список событий, представляющих
  эффект команды. Эти события сохраняются в дополнение к тому, чтобы применяться к состоянию компонента. Самое приятное в
   этой схеме состоит в том, что события только когда-либо присоединяются к хранилищу, ничто никогда не мутируется; это
    обеспечивает идеальную репликацию и масштабирование потребителей этого потока событий (т. е. другие компоненты могут
     потреблять поток событий как средство для репликации состояния компонента на другом континенте или для реагирования
      на изменения). Если состояние компонента потеряно - из-за сбоя машины или выталкивания из кеша - его можно 
      восстановить, переиздав поток событий (обычно используя моментальные снимки для ускорения процесса). Поиск событий
       поддерживается поддержкой Akka Persistence.

#### Почтовый ящик с явным подтверждением
Внедряя пользовательский тип почтового ящика, можно повторить обработку сообщения на конце принимающего актора для 
обработки временных сбоев. Этот шаблон в основном полезен в контексте местной связи, где гарантии доставки в противном
 случае достаточны для удовлетворения требований приложения.

### Мертвые письма
Сообщения, которые не могут быть доставлены (и для которых это может быть установлено), будут доставлены синтетическому
 актору, названному / deadLetters. Эта поставка происходит с максимальной эффективностью; он может выйти из строя даже
  в пределах локальной JVM (например, во время прекращения действия актора). Сообщения, отправленные через ненадежные
   сетевые транспортные средства, будут потеряны, если не будут отображаться как мертвые письма.

#### Для чего я должен использовать мертвые письма?
Основное использование этого средства предназначено для отладки, особенно если отправка актора не поступает постоянно
 (где обычно проверка мертвых писем будет свидетельствовать о том, что отправитель или получатель неправильно установлены
  где-то на этом пути). Чтобы быть полезными для этой цели, рекомендуется избегать отправки в `deadLetters`, где это 
  возможно, то есть запускать приложение с подходящим регистратором мертвых писем (см. Ниже) время от времени и очищать 
  выход журнала. Это упражнение, как и все остальное, требует разумного применения здравого смысла: вполне возможно, 
  что избегать отправки завершенному актору усложняет код отправителя больше, чем получается при ясности вывода отладки.

Служба мертвых писем соответствует тем же правилам в отношении гарантий доставки, что и все другие сообщения, поэтому 
он не может использоваться для реализации гарантированной доставки.

#### Как получить мертвые письма?
Актор может подписаться на класс `akka.actor.DeadLetter` в потоке событий. 
Подписанный актор затем получит все мертвые письма, опубликованные в (локальной) системе с этого момента. Мертвые 
письма не распространяются по сети, если вы хотите их собрать в одном месте, вам придется подписаться на одного 
участника на сетевой узел и переслать их вручную. Также учтите, что на этом узле генерируются мертвые письма, которые
 могут определять, что операция отправки не удалась, что для удаленной отправки может быть локальной системой (если 
 сетевое подключение не может быть установлено) или удаленным (если актор, который вы отправляете до этого не существует).

#### Мертвые письма, которые (как правило) не ужасают
Каждый раз, когда актор не заканчивается своим собственным решением, существует вероятность того, что некоторые 
сообщения, которые он отправляет себе, будут потеряны. Существует один, который довольно легко встречается в сложных
 сценариях выключения, которые обычно являются доброкачественными: вид akka.dispatch.Terminate сообщение сброшено 
 означает, что были предоставлены два запроса на завершение, но только один может быть успешным. В том же ключе вы 
 можете увидеть akka.actor.Terminated сообщения от детей, останавливая иерархию акторов, переворачиваясь мертвыми 
 письмами, если родитель все еще смотрит на ребенка, когда родитель завершает работу.
 
 [=> далее: Конфигурация](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/readmes/concepts/configuration.md)

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/akka/blob/akka_starter/readme.md)