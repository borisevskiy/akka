## Наблюдение и мониторинг

Наблюдатель делегирует задания подчиненным и, следовательно, должен реагировать на их сбои. Когда подчиненный обнаруживает 
сбой (т.е. выдает исключение), он приостанавливает себя и всех своих подчиненных и отправляет сообщение своему наблюдателю,
 сообщающее об ошибке. В зависимости от характора работы, подлежащей надзору, и характора отказа, у руководителя есть 
 выбор из следующих четырех вариантов:

1. **Возобновить** подчиненного, сохраняя его накопленное внутреннее состояние;
2. **Перезапустите** подчиненного, очистив ее накопленное внутреннее состояние;
3. **Остановить** подчиненного навсегда;
4. **Эскалировать** сбой, тем самым потерепеть неудачу самому.

Важно всегда рассматривать актора как часть иерархии наблюдения, что объясняет существование четвертого выбора (поскольку 
наблюдатель также подчинен другому руководителю выше) и имеет последствия для первых трех: **возобновление актора возобновляет 
всех его подчиненных, перезапуск актора влечет за собой перезапуск всех его подчиненных** (но см. ниже для более подробной 
информации), аналогичным завершением актора также прекращаются все его подчиненные. Следует отметить, что поведение по 
умолчанию для хука `preRestart` класса Actor заключается в том, чтобы завершить все его дочерние элементы перед 
перезапуском, но этот хук можно переопределить; рекурсивный перезапуск применяется ко всем детям, оставшимся после 
выполнения этого хука.

Каждый диспетчер сконфигурирован с функцией, переводящей все возможные причины отказа (то есть исключения) в один из 
четырех вариантов, указанных выше; в частности, эта функция не воспринимает идентичность отказавшего актора как входной. 
Очень легко придумать примеры структур, где это может показаться недостаточно гибким, например, желая, чтобы различные 
стратегии применялись к различным подчиненным. На этом этапе важно понять, что наблюдение заключается в формировании 
рекурсивной структуры обработки ошибок. Если вы попытаетесь сделать слишком много на одном уровне, это станет трудно 
поддерживать, поэтому рекомендуемым способом в этом случае является добавление уровня надзора.

Акка реализует определенную форму под названием `родительский надзор`. **Акторы могут создаваться только другими акторами** - 
где актор верхнего уровня предоставляется библиотекой, и **каждый созданный актор контролируется его родителем**. Это 
ограничение делает невозможным формирование иерархии надзора за актором и поощряет обоснованные проектные решения. 
Следует отметить, что это также гарантирует, что акторы не могут оставаться сиротами или прикрепляться к наблюдателям 
извне, что в противном случае могло бы застигнуть их врасплох. Кроме того, это дает естественную и чистую процедуру 
закрытия для (поддеревьев) акторских приложений.

> Внимание! Надзор, связанный с родительским и дочерним коммуникациями, происходит с помощью специальных системных 
сообщений, которые имеют свои собственные почтовые ящики отдельно от пользовательских сообщений. Это означает, что 
события, связанные с наблюдением, не детерминировано упорядочены относительно обычных сообщений. В общем, пользователь 
не может влиять на порядок сообщений о нормальных сообщениях и отказах. 

### Наблюдатели высшего уровня

![alt text](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/images/guardians.png "guardians")

Акторская система во время своего создания начнет как минимум три актора, показанных на изображении выше. Для получения 
дополнительной информации о последствиях для путей акторов см. Области верхнего уровня для контуров актора.

`/user:` **Актор Страж** (The Guardian Actor)

Актор, с которым, вероятно, больше всего взаимодействуют, является родителем всех созданных пользователем акторов - 
страж с именем `/user`. Акторы, созданные с помощью `system.actorOf()`, являются дочерними элементами этого актора. 
Это означает, что, когда этот страж завершится, все нормальные акторы в системе также будут отключены. Это также 
означает, что стратегия надзирателя этого опекуна определяет, как контролируются нормальные субъекты верхнего уровня. 
Это можно настроить, используя настройку `akka.actor.guardian-supervisor-strategy`, которая берет 
полностью квалифицированное имя класса `SupervisorStrategyConfigurator`. Когда страж эскалирует сбой, ответ корневого 
опекуна будет заключаться в том, чтобы остановить опекуна, который фактически отключит всю систему акторов.

`/system:`**Системный Страж** (The System Guardian)

Этот специальный страж был введен для того, чтобы добиться упорядоченной последовательности выключения, где ведение 
журнала остается активным, пока все нормальные участники прекращают свою работу, даже если сама регистрация осуществляется
 с использованием акторов. Это достигается за счет того, что системный охранник наблюдает за пользователем-опекуном и 
 инициирует собственное закрытие при приеме завершенного (`Terminated`) сообщения. Акторы верхнего уровня контролируются с использованием
  стратегии, которая будет возобновляться неограниченно на всех типах исключений, за исключением 
  `ActorInitializationException` и `ActorKilledException`, что приведет к прекращению рассматриваемого ребенка. Все 
  другие метаданные эскалированы, что приведет к остановке всей системы акторов.

`/:` **Корневой Страж** (The Root Guardian)

Корневой Страж является родоначальником всех так называемых «топ-уровней» акторов и контролирует всех специальных 
участников, упомянутых в областях верхнего уровня для контуров актора, с помощью `SupervisorStrategy.stoppingStrategy`, 
целью которого является прекращение ребенка на любом типе исключения. Все другие исключения будут эскалированы ... 
но кем? Поскольку у каждого реального актора есть супервизор, супервайзер корневого опекуна не может быть настоящим 
актором. И поскольку это означает, что он «вне пузыря», это называется «пузырь-ходок». Это синтетический `ActorRef`, 
который фактически останавливает его ребенка по первому признаку проблемы и устанавливает статус `isTerminated` действующей 
системы как `true`, как только страж корня полностью завершается (все дети рекурсивно останавливаются).

### Что такое перезапуск
При представлении актора, который не работал при обработке определенного сообщения, причины отказа делятся на три категории:

* Систематическая (то есть запрограммированная) ошибка для конкретного полученного сообщения;
* (Временная (`Transient`)) отказ какого-либо внешнего ресурса, используемого при обработке сообщения;
* Испорченное внутреннее состояние актора.

Если отказ не является однозначно узнаваемым (третья причина не может быть исключена), что приводит к выводу, что 
внутреннее состояние необходимо очистить. Если надзорный орган решает, что на его других детей или на себя не влияет 
порча. Из-за сознательного применения шаблона ядра ошибок - поэтому лучше всего перезапустить дочерний элемент. 
Это выполняется, создавая новый экземпляр базового класса `Actor` и заменяя неудавшийся экземпляр свежим внутри `ActorRef`; 
способность делать это является одной из причин инкапсуляции акторов в специальные ссылки. Затем новый актор возобновляет 
обработку своего почтового ящика, что означает, что перезапуск не виден вне самого актора с заметным исключением, что 
сообщение, в течение которого произошел сбой, не переработано повторно.

Точная последовательность событий во время перезагрузки следующая:

1. приостановить действие актора (что означает, что он не будет обрабатывать нормальные сообщения до возобновления) и 
рекурсивно приостановить всех детей;
2. вызвать привязку `preRestart` старого экземпляра (по умолчанию отправляет запросы завершения для всех детей и 
вызывается `postStop`);
3. подождать, пока все дети, которым было предложено прекратить (используя `context.stop()`) во время `preRestart`, 
фактически завершатся; это, как и все действия актора, не является блокирующим, уведомление об окончании последнего 
убитого ребенка будет влиять на переход на следующий шаг;
4. создать новый экземпляр актора, вызвав первоначально предоставленную фабрику снова;
5. выполнить `postRestart` в новом экземпляре (который по умолчанию также вызывает `preStart`);
6. отправить запрос на перезагрузку всем детям, которые не были убиты на шаге 3; перезапущенные дети будут следовать 
за тем же процессом рекурсивно, начиная с шага 2;
7. возобновить актор.

### Что означает мониторинг жизненного цикла
>Мониторинг жизненного цикла в Акке обычно называется `DeathWatch`

В отличие от особой взаимосвязи между родителем и ребенком, описанной выше, **каждый актор может контролировать любого 
другого актора**. Поскольку акторы выходят из создания полностью живыми, и перезапуска не видны за пределами затронутых 
супервизоров, единственным изменением состояния, доступным для мониторинга, является **переход от живого к мертвому**. 
Мониторинг, таким образом, используется для привязки одного актора к другому, чтобы он мог реагировать на прекращение 
действия другого участника, в отличие от наблюдения, которое реагирует на отказ.

Мониторинг жизненного цикла реализуется с использованием завершенного (`Terminated`) сообщения, которое должно быть получено 
участником мониторинга, где поведение по умолчанию - это бросить специальное исключение `DeathPactException`, если оно 
не обрабатывается иным образом. Чтобы начать прослушивание завершенных сообщений, вызовите `ActorContext.watch(targetActorRef)`.
 Чтобы прекратить прослушивание, вызовите `ActorContext.unwatch(targetActorRef)`. Одним из важных свойств является то, 
 что сообщение будет доставлено независимо от порядка, в котором происходит запрос на мониторинг и завершение цели, 
 то есть вы все равно получаете сообщение, даже если во время регистрации цель уже мертва.

Мониторинг особенно полезен, если супервизор не может перезапустить своих детей и должен их прекратить, например, 
в случае ошибок во время инициализации актора. В этом случае он должен следить за этими детьми и воссоздавать их или 
планировать себя, чтобы повторить это позже.

Другим распространенным случаем является то, что актор должен потерпеть неудачу в отсутствие внешнего ресурса, 
который также может быть одним из его собственных детей. Если третья сторона прекращает действие ребенка с помощью 
метода `system.stop(child)` или отправки `PoisonPill`, надзорник может быть затронут.

### Задержка перезапуска с шаблоном `BackoffSupervisor`
Предоставляемый в виде встроенного шаблона `akka.pattern.BackoffSupervisor` реализует так называемую 
`стратегия экспоненциального отсрочки`, начиная с дочернего актора, когда он терпит неудачу, каждый раз с растущей 
временной задержкой между перезапусками.

Этот шаблон полезен, когда запущенный актор терпит неудачу [1], потому что какой-то внешний ресурс недоступен, и нам 
нужно дать ему некоторое время для запуска снова. Одним из главных примеров, когда это полезно, является то, что 
`PersistentActor` терпит неудачу (путем остановки) с отказом персистентности - что указывает на то, что база данных 
может быть опущена или перегружена, в таких ситуациях имеет смысл дать ей немного времени, чтобы прежде чем начнется 
постоянный актор.

>[1] Ошибка может быть указана двумя разными способами; актор останавливается или падает.

Следующий фрагмент Scala показывает, как создать супервизор, который запустит данный эхо-актор после его остановки 
из-за сбоя, с увеличением интервалов 3, 6, 12, 24 и, наконец, 30 секунд:

```scala
    val childProps = Props(classOf[EchoActor])
    
    val supervisor = BackoffSupervisor.props(
      Backoff.onStop(
        childProps,
        childName = "myEcho",
        minBackoff = 3.seconds,
        maxBackoff = 30.seconds,
        randomFactor = 0.2, // adds 20% "noise" to vary the intervals slightly
        maxNrOfRetries = -1
      ))
    
    system.actorOf(supervisor, name = "echoSupervisor")
```

Вышеупомянутое эквивалентно этому Java-коду:

`Акка.pattern.BackoffOptions` можно использовать для настройки поведения отступающего актора-наблюдателя, ниже приведены
 некоторые примеры:
 
 ```scala
     val supervisor = BackoffSupervisor.props(
       Backoff.onStop(
         childProps,
         childName = "myEcho",
         minBackoff = 3.seconds,
         maxBackoff = 30.seconds,
         randomFactor = 0.2, // добавляет 20% «шума», чтобы немного варьировать интервалы
         maxNrOfRetries = -1
       ).withManualReset // ребенок должен отправить BackoffSupervisor.Reset для своего родителя
         .withDefaultStoppingStrategy // Остановитесь при любом исключении
     )
 ```

Вышеприведенный код устанавливает резервный супервизор, который требует, чтобы дочерний актор отправил сообщение 
`akka.pattern.BackoffSupervisor.Reset` своему родителю, когда сообщение успешно обработано, сбросив его. Он также 
использует стратегию остановки по умолчанию, любое исключение приведет к остановке ребенка.

 ```scala
     val supervisor = BackoffSupervisor.props(
       Backoff.onFailure(
         childProps,
         childName = "myEcho",
         minBackoff = 3.seconds,
         maxBackoff = 30.seconds,
         randomFactor = 0.2, // добавляет 20% «шума», чтобы немного варьировать интервалы
         maxNrOfRetries = -1
       ).withAutoReset(10.seconds) // сбрасывать, если ребенок не бросает никаких ошибок в течение 10 секунд
         .withSupervisorStrategy(
           OneForOneStrategy() {
             case _: MyException ⇒ SupervisorStrategy.Restart
             case _              ⇒ SupervisorStrategy.Escalate
           }))
 ```
 
 Вышеупомянутый код устанавливает резервный супервизор, который перезапускает дочерний элемент после резервного 
 копирования, если `MyException` брошено, любое другое исключение будет эскалировано. Откат автоматически сбрасывается, 
 если ребенок не бросает никаких ошибок в течение 10 секунд.
 
 ### Стратегия `один-для-одного (AllForOneStrategy)` против `все-для-одного (All-For-One Strategy)`
 Существует два класса стратегий надзора, которые поставляются с Акка: `OneForOneStrategy` и `AllForOneStrategy`. 
 Оба они настроены с отображением из типа исключения в директиву надзора (см. Выше) и ограничениями того, как часто 
 ребенку разрешается провалиться, прежде чем завершать его. Разница между ними заключается в том, что первая применяет 
 полученную директиву только к неудавшемуся ребенку, тогда как последняя применяет ее ко всем братьям и сестрам. Как 
 правило, вы должны использовать OneForOneStrategy, который также является значением по умолчанию, если ни один не указан явно.
 
 `AllForOneStrategy` применима в случаях, когда у ансамбля детей есть такие плотные зависимости между ними, что отказ 
 одного ребенка влияет на функцию других, т.е. они неразрывно связаны. Поскольку перезапуск не очищает почтовый ящик, 
 часто бывает лучше прекратить работу с детьми после сбоя и повторно создать их явно из супервизора (просмотрев жизненный 
 цикл детей); в противном случае вы должны убедиться, что никому из участников не нужно получать сообщение, которое 
 было поставлено в очередь перед перезагрузкой, но затем обработано.
 
Обычно остановка ребенка (т.е. не в ответ на сбой) не будет автоматически прерывать других детей в стратегии 
«все-для-одного»; это можно сделать, просмотрев их жизненный цикл: если обработанное сообщение не было обработано 
супервизором, оно вызовет исключение `DeathPactException`, которое (в зависимости от его супервизора) перезапустит его, 
а действие preRestart по умолчанию прекратит все дочерние элементы. Конечно, это можно обработать также явно.

Обратите внимание, что создание одноразовых участников из супервизора «все-к-одному» влечет за собой то, что неудачи, 
вызванные временным игроком, затронут все постоянные. Если это нежелательно, установите промежуточного диспетчера; это 
может быть сделано путем объявления маршрутизатора размером 1 для рабочего.
 
_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/akka/blob/akka_starter/readme.md)