## Терминология, концепции

В этой главе мы попытаемся установить общую терминологию, чтобы определить прочную основу для передачи информации о 
параллельных распределенных системах, к которым стремится Акка. Обратите внимание, что для многих из этих терминов нет 
единого согласованного определения. Мы стремимся дать рабочие определения, которые будут использоваться в рамках документации Akka.

### Согласованность и параллелизм (Concurrency vs. Parallelism)
Согласованность и параллелизм - это связанные понятия, но есть небольшие различия. Параллелизм означает, что две или 
более задачи достигают прогресса, даже если они не могут выполняться одновременно. Это может быть реализовано, например, 
с временным разделением, когда части задач выполняются последовательно и смешиваются с частями других задач. 
С другой стороны, параллелизм возникает, когда выполнение может быть действительно одновременным.

### Асинхронный и синхронный
Вызов метода считается синхронным, если вызывающий не может достигнуть прогресса, пока метод не вернет значение или не 
вызовет исключение. С другой стороны, асинхронный вызов позволяет вызывающему абоненту прогрессировать после конечного 
числа шагов, а завершение метода может быть передано через некоторый дополнительный механизм (это может быть зарегистрированный 
обратный вызов, будущее или сообщение).

Синхронный API может использовать блокировку для реализации синхронизации, но это не является необходимостью. Очень 
интенсивная задача CPU может привести к аналогичному поведению, как блокирование. В общем, предпочтительно использовать 
асинхронные API-интерфейсы, поскольку они гарантируют, что система сможет прогрессировать. Актеры асинхронны по своей 
природе: актер может прогрессировать после отправки сообщения, не дожидаясь фактической доставки.

### Неблокирование и блокирование
Мы говорим о блокировке, если задержка одного потока может бесконечно задерживать некоторые другие потоки. Хорошим 
примером является ресурс, который может использоваться исключительно одним потоком, используя взаимное исключение. Если
 поток держится на ресурсе неограниченно (например, случайно запуская бесконечный цикл), другие потоки, ожидающие ресурса,
  не могут развиваться. Напротив, неблокирование означает, что нить не может бесконечно задерживать других.

Неблокирующие операции предпочтительнее блокировки, так как общий прогресс системы не является тривиально гарантированным,
 когда он содержит операции блокировки.

### Тупик против голодания против Live-Lock (Deadlock vs. Starvation vs. Live-lock)
Тупик возникает, когда несколько участников ждут друг друга, чтобы достичь определенного состояния, чтобы иметь 
возможность прогресса. Поскольку ни один из них не может продвигаться без какого-либо другого участника для достижения 
определенного состояния (проблема «Catch-22»), все затронутые подсистемы останавливаются. Тупик тесно связан с блокировкой,
 так как необходимо, чтобы поток участников мог задерживать прогрессирование других потоков на неопределенный срок.

В случае тупика ни один из участников не может продвигаться вперед, в то время как в отличие от Голода, когда есть 
участники, которые могут добиться прогресса, но может быть один или несколько, что не может. Типичный сценарий - это 
пример наивного алгоритма планирования, который всегда выбирает приоритетные задачи над низкоприоритетными. Если количество
 входящих высокоприоритетных задач постоянно достаточно высокое, ни одно из них не будет выполнено.

`Livelock` похож на тупик, так как никто из участников не продвигается вперед. Разница заключается в том, что вместо того,
 чтобы застыть в состоянии ожидания прогресса других, участники постоянно меняют свое состояние. Примерный сценарий, 
 когда два участника имеют два одинаковых доступных ресурса. Каждый из них пытается получить ресурс, но они также 
 проверяют, нуждается ли другой ресурс. Если ресурс запрашивается другим участником, они пытаются получить другой 
 экземпляр ресурса. В неудачном случае может случиться так, что два участника «отскакивают» между этими двумя ресурсами,
  никогда не приобретая его, но всегда уступая другому.

### Состояние гонки
Мы называем это условием Расы, когда предположение о упорядочении множества событий может быть нарушено внешними 
недетерминированными эффектами. Условия гонки часто возникают, когда несколько потоков имеют общее изменяемое состояние,
 а операции потока в состоянии могут чередоваться, что приводит к неожиданному поведению. Хотя это общий случай, 
 разделенное государство не обязательно должно иметь условия гонки. Одним из примеров может быть клиент, отправляющий 
 неуправляемые пакеты (например, датаграммы UDP) P1, P2 на сервер. Поскольку пакеты могут потенциально путешествовать по 
 различным сетевым маршрутам, возможно, что сервер сначала получит P2 и P1. Если в сообщениях нет информации об их заказе 
 на отправку, невозможно определить сервером, что они были отправлены в другом порядке. В зависимости от значения пакетов 
 это может привести к условиям гонки.

> Единственная гарантия, которую Akka предоставляет в сообщениях, отправленных между данной парными актерами, заключается 
в том, что их порядок всегда сохраняется.

### Неблокирующие гарантии (условия выполнения)
Как обсуждалось в предыдущих разделах, блокирование нежелательно по нескольким причинам, включая опасность взаимоблокировок
 и снижение пропускной способности в системе. В следующих разделах мы обсудим различные неблокирующие свойства с разной прочностью.

### Свобода ожидания
Метод `Wait-freed`, если каждый вызов будет завершен с конечным числом шагов. Если метод ограничен без ожидания, то 
число шагов имеет конечную верхнюю границу.

Из этого определения следует, что методы без ожидания никогда не блокируются, поэтому взаимоблокировки не может быть. 
Кроме того, по мере того, как каждый участник может прогрессировать после конечного числа шагов (когда заканчивается 
звонок), безжизненные методы освобождаются от голода.

#### Свобода блокировки
`Lock-freedom` - это более слабое свойство, чем свобода ожидания. В случае бесконтактных вызовов бесконечно часто какой-то 
метод заканчивается на конечном числе шагов. Это определение подразумевает невозможность взаимоблокировки для звонков 
без блокировки. С другой стороны, гарантии того, что некоторые звонки заканчиваются на конечном количестве шагов, 
недостаточно, чтобы гарантировать, что все они в конечном итоге закончатся. Другими словами, свободы замка недостаточно, 
чтобы гарантировать отсутствие голода.

#### Свобода обструкции
`Obstruction-freedom` - это самая слабая неблокирующая гарантия, обсуждаемая здесь. Метод называется непротиворечивым, если есть 
точка во времени, после которой она выполняется изолированно (другие потоки не выполняют никаких шагов, например: становятся 
приостановленными), она заканчивается ограниченным числом шагов. Все объекты, свободные от блокировки, являются 
обструкционированными, но противоположное, как правило, неверно.

Оптимистичные методы контроля параллелизма обычно являются обструктивными. Подход OCC заключается в том, что 
каждый участник пытается выполнить свою операцию на общему объекте, но если участник обнаруживает конфликты с другими, 
он откатывает изменения и повторяет попытку в соответствии с некоторым графиком. Если есть момент времени, когда один из 
участников является единственным, кто пытается, операция будет успешной.

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/akka/blob/akka_starter/readme.md)