## Часть 1: Архитектура актора

>Добавьте в свой проект следующую зависимость:
```scala
    libraryDependencies += "com.typesafe.akka" %% "akka-actor" % "2.5.17"
```

### Введение

**Использование Akka избавляет вас от создания инфраструктуры для системы акторов и от написания низкоуровневого кода, 
необходимого для управления базовым поведением.** _Чтобы оценить это, давайте посмотрим на отношения между действующими вами 
субъектами в вашем коде и теми, которые Akka создает и управляет для вас внутренне, жизненный цикл актора и обработку отказа._

### Иерархия акторов в Акка

Актор в Акке всегда принадлежит родителям. Как правило, вы создаете актора, вызывая **`context.actorOf()`**. Вместо того, 
чтобы создавать «независимого» актора, это создает нового актора в качестве ребенка в уже существующее дерево: создатель-актор 
становится родителем только что созданного дочернего актора. Тогда вы можете спросить, кто является родителем первого 
созданного вами актора?

Как показано ниже, у всех участников есть общий родитель, пользователь-хранитель. С помощью `system.actorOf()` можно создавать 
новые экземпляры акторов под этим актором. Как мы рассмотрели в Руководстве по быстрому запуску, создание актора возвращает 
ссылку, которая является допустимым URL. Так, например, если мы создадим актора с именем `someActor` с 
**`system.actorOf (..., «someActor»)`**, его ссылка будет включать путь `/user/someActor`.

![alt text](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/images/actor_top_tree.png "actor_top_tree")

На самом деле, прежде чем вы создадите актора в своем коде, **Akka уже создал трех действующих лиц в системе**. Имена 
этих встроенных акторов содержат опекуна (**`guardian`**), потому что они контролируют каждого дочернего актора на своем пути. 
Акторы-опекуны (`guardian actors`) включают:

* `/root` guardian (корневой опекун). Это родительский элемент всех участников системы, а последний 
останавливается, когда сама система завершается;

* `/user`  guardian (пользовательский опекун). Это родительский актор для всех созданных пользователем участников. 
Не допускайте, чтобы имя пользователя вас путало, оно не имеет ничего общего с конечными пользователями и с пользовательской 
обработкой. Каждый актор, созданный с использованием библиотеки Akka, будет иметь постоянный путь `/user/` добавленный к нему;

* `/system` guardian (системный опекун).

В примере `AkkaQuickstart` мы уже видели, как `system.actorOf()` создает актора непосредственно под `/user`. Мы называем 
это `актором верхнего уровня (top level actor)`, хотя на практике он находится только на вершине определяемой пользователем 
иерархии. У вас обычно есть только один (или очень немногие) акторы верхнего уровня в вашей `ActorSystem`. Мы создаем 
дочерних или неактивных участников, вызывая `context.actorOf()` от существующего актора. Метод `context.actorOf()` имеет 
подпись, идентичную `system.actorOf()`, ее аналог верхнего уровня.

Самый простой способ увидеть иерархию акторов в действии - распечатать экземпляры `ActorRef`. В этом небольшом эксперименте 
мы создаем актора, печатаем его ссылку, создаем ребенка этого актора и печатаем ссылку на ребенка. Мы начинаем с 
проекта `AkkaQuickstart`.

В проекте `AkkaQuickstart` перейдите к пакету `ru.sample` и запустите в консоли: 
 
 ```sbtshell
    cd C:\projects\Akka
    sbt «runMain ru.sample.ActorHierarchyExperiments»
 ```
 
 >класс PrintMyActorRefActor:
 
 ```scala
    package ru.sample
    
    import akka.actor.{ Actor, Props, ActorSystem }
    import scala.io.StdIn
    
    class PrintMyActorRefActor extends Actor {
      override def receive: Receive = {
        case "printit" ⇒
          val secondRef = context.actorOf(Props.empty, "second-actor")
          println(s"Second: $secondRef")
      }
    }
    
    object ActorHierarchyExperiments extends App {
      val system = ActorSystem("testSystem")
    
      val firstRef = system.actorOf(Props[PrintMyActorRefActor], "first-actor")
      println(s"First: $firstRef")
      firstRef ! "printit"
    
      println(">>> Press ENTER to exit <<<")
      try StdIn.readLine()
      finally system.terminate()
    }

 ```
 
Обратите внимание на то, как сообщение просило первого актора выполнить свою работу. Мы отправили сообщение, используя 
ссылку родителя: `firstRef! "Printit"`. Когда код выполняется, вывод включает ссылки для первого актора и ребенка, 
который он создал как часть `printit`. Результат должен выглядеть примерно так:
  
 ```sbtshell
     First:  Actor[akka://testSystem/user/first-actor#-1856311964]
     Second: Actor[akka://testSystem/user/first-actor/second-actor#1225562397]
 ```
 
Обратите внимание на структуру ссылок:

* Оба пути начинаются с `akka://testSystem /`. Поскольку все ссылки на акторы являются действительными URL-адресами, 
`akka:// `является значением поля протокола;

* Далее, как и во Всемирной паутине, URL-адрес идентифицирует систему. В этом примере система называется `testSystem`, 
но это может быть любое другое имя. Если удаленная связь между несколькими системами включена, эта часть URL-адреса 
включает имя хоста, чтобы другие системы могли найти его в сети;

* Поскольку ссылка второго актора включает в себя путь `/first-actor/`, он идентифицирует его как ребенка первого;

* Последняя часть ссылки на актора, `#-1856311964` или `#1225562397` - уникальный идентификатор, который вы можете 
игнорировать в большинстве случаев.

Теперь, когда вы понимаете, как выглядит иерархия акторов, вам может быть интересно: _зачем нам нужна эта иерархия?_ 

Важной ролью иерархии является безопасное управление жизненными циклами акторов. Давайте рассмотрим это дальше и посмотрим,
 как эти знания помогут нам лучше писать код.
 
 
 

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/akka/blob/akka_starter/readme.md)