## Почему современным системам нужна новая модель программирования

[Модель актора](https://ru.wikipedia.org/wiki/Модель_акторов) была предложена десятилетиями назад [Карлом Хьюиттом](https://en.wikipedia.org/wiki/Carl_Hewitt) 
как способ параллельной обработки в высокопроизводительной сети - среде, недоступной в то время. Сегодня аппаратные и 
инфраструктурные возможности догнали и превысили видение Хьюитта. Следовательно, организации, строящие распределенные 
системы с высокими требованиями, сталкиваются с проблемами, которые не могут быть полностью решены с помощью традиционной 
модели объектно-ориентированного программирования (ООП), но это может быть достигнуто при помощи модели актора.

Сегодня модель актора не только признана высокоэффективным решением - она доказана в производстве для некоторых из самых 
требовательных приложений в мире. Чтобы выделить проблемы, которые адресована моделью актора, в этом разделе обсуждаются 
следующие несоответствия между традиционными предположениями о программировании и реальностью современных многопоточных 
многопроцессорных архитектур.

### Проблема инкапсуляции

Основным элементом ООП является `инкапсуляция`. Инкапсуляция диктует, что внутренние данные объекта недоступны непосредственно 
извне; его можно изменить только путем вызова набора кураторских методов. Объект несет ответственность за раскрытие безопасных
 операций, которые защищают инвариантный характер его инкапсулированных данных.

_Например, операции над реализацией упорядоченного двоичного дерева не должны допускать нарушения инварианта упорядочения 
дерева. Клиенты `api` ожидают, что порядок будет неповрежденным, и при запросе дерева для определенной части данных они должны 
быть в состоянии полагаться на это ограничение._

Когда мы анализируем поведение времени выполнения ООП, мы иногда рисуем диаграмму последовательности сообщений, показывающую 
взаимодействие вызовов методов. Например:

![alt text](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/images/why-modern-systems-need-anew-programming-model/seq_chart.png "seq_chart")

К сожалению, приведенная выше диаграмма не точно отражает жизненные линии экземпляров во время выполнения. На самом деле 
поток выполняет все эти вызовы, а принудительное выполнение инвариантов происходит в том же потоке, из которого был вызван 
метод. Обновляя диаграмму потоком выполнения, она выглядит так:

![alt text](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/images/why-modern-systems-need-anew-programming-model/seq_chart_thread.png "seq_chart_thread")

Значение этого пояснения становится ясным, когда вы пытаетесь моделировать то, что происходит с несколькими потоками. 
Вдруг наша аккуратно нарисованная диаграмма становится неадекватной. Мы можем попытаться проиллюстрировать несколько потоков,
 обращаясь к одному экземпляру:
 
 ![alt text](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/images/why-modern-systems-need-anew-programming-model/seq_chart_multi_thread.png "seq_chart_multi_thread")

Существует **раздел выполнения**, в котором два потока вводят один и тот же метод. К сожалению, модель объектов инкапсуляции
 не гарантирует ничего о том, что происходит в этом разделе. Инструкции по двум вызовам могут чередоваться произвольными 
 способами, которые устраняют любую надежду на сохранение инвариантов без изменений без какой-либо координации между двумя 
 потоками. Теперь представьте, что этот вопрос усугубляется существованием множества потоков.

Общий подход к решению этой проблемы заключается в добавлении блокировки этих методов. Хотя это гарантирует, что не более 
одного потока будет вводить метод в любой момент времени, это очень дорогостоящая стратегия:

* Замки (`locks`) серьезно ограничивают параллелизм, они очень дорогостоящие на современных архитектурах процессоров, 
требующих тяжелого подъема из операционной системы, чтобы приостановить поток и восстановить его позже.

* Теперь поток вызывающий заблокирован, поэтому он не может выполнять какую-либо другую значимую работу. Даже в настольных 
приложениях это неприемлемо, поэтому мы хотим, чтобы пользовательские интерфейсы, зависящие от пользователя (его пользовательский
 интерфейс), реагировали даже при работе с длинным фоном. В бэкэнд блокировка полностью расточительна. Можно подумать, 
 что это может быть компенсировано пуском новых потоков, но потоки также являются дорогостоящей абстракцией.

* Замки представляют новую угрозу: дэдлки.

Эти реалии приводят к беспроигрышной ситуации:

* Без достаточных блокировок состояние становится поврежденным.

* Со многими замками на месте, производительность страдает и очень легко приводит к взаимоблокировкам.

Кроме того, шлюзы работают очень хорошо. Когда дело доходит до координации нескольких машин, единственной альтернативой 
являются распределенные блокировки. К сожалению, распределенные блокировки на несколько величин менее эффективны, чем 
локальные блокировки, и обычно налагают жесткий предел на масштабирование. Протоколы распределенных блокировок требуют 
нескольких обходов связи по сети через несколько компьютеров, поэтому латентность весьма увеличивается.

В объектно-ориентированных языках мы редко думаем о потоках или линейных путях выполнения в целом. Мы часто представляем 
систему как сеть экземпляров объектов, которые реагируют на вызовы методов, изменяют их внутреннее состояние, а затем 
общаются друг с другом посредством вызовов методов, ведущих вперед все состояние приложения:

 ![alt text](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/images/why-modern-systems-need-anew-programming-model/object_graph.png "object_graph")

Однако в многопоточной распределенной среде фактически происходит то, что потоки «пересекают» эту сеть экземпляров объектов, 
следуя вызовам метода. В результате потоки действительно приводят к выполнению:

 ![alt text](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/images/why-modern-systems-need-anew-programming-model/object_graph_snakes.png "object_graph_snakes")

### В итоге:

* **Объекты могут гарантировать только инкапсуляцию (защиту инвариантов) перед однопоточным доступом, многопоточное 
выполнение почти всегда приводит к поврежденному внутреннему состоянию. Каждый инвариант может быть нарушен за счет наличия 
двух конкурирующих потоков в одном и том же сегменте кода.**

* **Хотя блокировки, по-видимому, являются естественным средством защиты инкапсуляции несколькими потоками, на практике 
они неэффективны и легко приводят к взаимоблокировкам при любом применении реального масштаба.**

* **Замки работают локально, попытки их распространения существуют, но предлагают ограниченный потенциал для масштабирования.**


_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._