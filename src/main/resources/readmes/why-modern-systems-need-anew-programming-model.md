## Почему современным системам нужна новая модель программирования

[Модель актора](https://ru.wikipedia.org/wiki/Модель_акторов) была предложена десятилетиями назад [Карлом Хьюиттом](https://en.wikipedia.org/wiki/Carl_Hewitt) 
как способ параллельной обработки в высокопроизводительной сети - среде, недоступной в то время. Сегодня аппаратные и 
инфраструктурные возможности догнали и превысили видение Хьюитта. Следовательно, организации, строящие распределенные 
системы с высокими требованиями, сталкиваются с проблемами, которые не могут быть полностью решены с помощью традиционной 
модели объектно-ориентированного программирования (ООП), но это может быть достигнуто при помощи модели актора.

Сегодня модель актора не только признана высокоэффективным решением - она доказана в производстве для некоторых из самых 
требовательных приложений в мире. Чтобы выделить проблемы, которые адресована моделью актора, в этом разделе обсуждаются 
следующие несоответствия между традиционными предположениями о программировании и реальностью современных многопоточных 
многопроцессорных архитектур.

### Проблема инкапсуляции

Основным элементом ООП является `инкапсуляци`я. Инкапсуляция диктует, что внутренние данные объекта недоступны непосредственно 
извне; его можно изменить только путем вызова набора кураторских методов. Объект несет ответственность за раскрытие безопасных
 операций, которые защищают инвариантный характер его инкапсулированных данных.

_Например, операции над реализацией упорядоченного двоичного дерева не должны допускать нарушения инварианта упорядочения 
дерева. Клиенты `api` ожидают, что порядок будет неповрежденным, и при запросе дерева для определенной части данных они должны 
быть в состоянии полагаться на это ограничение._

Когда мы анализируем поведение времени выполнения ООП, мы иногда рисуем диаграмму последовательности сообщений, показывающую 
взаимодействие вызовов методов. Например:

![alt text](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/images/why-modern-systems-need-anew-programming-model/seq_chart.png "seq_chart")

К сожалению, приведенная выше диаграмма не точно отражает жизненные линии экземпляров во время выполнения. На самом деле 
поток выполняет все эти вызовы, а принудительное выполнение инвариантов происходит в том же потоке, из которого был вызван 
метод. Обновляя диаграмму потоком выполнения, она выглядит так:



_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._