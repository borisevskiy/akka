## Акторы

### Вступление
Модель Actor обеспечивает более высокий уровень абстракции для написания параллельных и распределенных систем. Это 
позволяет разработчику отказаться от явной блокировки и управления потоками, что упрощает создание правильных 
параллельных и параллельных систем. Акторы были определены в газете Карла Хьюитта в 1973 году, но были популяризированы 
языком Erlang и использовались, например, в Эрикссон с большим успехом для создания высококонкурентных и надежных 
телекоммуникационных систем.

### Создание акторов

#### Определение класса Actor
Акторы реализуются путем расширения базового типажа Актора и реализации метода `receive`. Метод **`receive`** должен определять 
ряд операторов `case` (который имеет тип `PartialFunction[Any, Unit]`), который определяет, какие сообщения может 
обрабатывать ваш актор, используя стандартное сопоставление шаблонов Scala, а также реализацию того, как сообщения 
должны обрабатываться.

Вот пример:

```scala
import akka.actor.Actor
import akka.actor.Props
import akka.event.Logging

class MyActor extends Actor {
  val log = Logging(context.system, this)

  def receive = {
    case "test" ⇒ log.info("получен тест")
    case _      ⇒ log.info("получено неизвестное сообщение")
  }
}
```

Обратите внимание, что `receive` цикл сообщений является исчерпывающим. Это означает, что вам необходимо предоставить 
соответствие шаблону всем сообщениям, которые оно может принять, и если вы хотите иметь возможность обрабатывать 
неизвестные сообщения, тогда вам нужно иметь случай по умолчанию, как в приведенном выше примере. В противном случае 
`akka.actor.UnhandledMessage` (`message`, `sender`, `recipient`) будет опубликован в `ActorSystem`s `EventStream`.

Обратите внимание, что возвращаемый тип поведения, определенный выше, - `Unit`; если актор должен ответить на полученное сообщение, это должно быть сделано явно, как описано ниже.

Результатом метода `receive` является объект частичной функции, который хранится внутри актора в качестве его 
«первоначального поведения».

```scala
import akka.actor.{ ActorSystem, Actor, ActorRef, Props, PoisonPill }
import language.postfixOps
import scala.concurrent.duration._

case object Ping
case object Pong

class Pinger extends Actor {
  var countDown = 100

  def receive = {
    case Pong ⇒
      println(s"${self.path} received pong, count down $countDown")

      if (countDown > 0) {
        countDown -= 1
        sender() ! Ping
      } else {
        sender() ! PoisonPill
        self ! PoisonPill
      }
  }
}

class Ponger(pinger: ActorRef) extends Actor {
  def receive = {
    case Ping ⇒
      println(s"${self.path} received ping")
      pinger ! Pong
  }
}

    val system = ActorSystem("pingpong")

    val pinger = system.actorOf(Props[Pinger], "pinger")

    val ponger = system.actorOf(Props(classOf[Ponger], pinger), "ponger")

    import system.dispatcher
    system.scheduler.scheduleOnce(500 millis) {
      ponger ! Ping
    }
```

#### Реквизит (Props)
`Props` - это класс конфигурации, который указывает параметры для создания участников, рассматривая его как непреложный 
и, следовательно, свободно распространяемый рецепт создания актора, включая связанную информацию о развертывании 
(например, какой диспетчер использовать). Вот несколько примеров создания экземпляра реквизита.

```scala
import akka.actor.Props

val props1 = Props[MyActor]
val props2 = Props(new ActorWithArgs("arg")) // осторожно, см. ниже
val props3 = Props(classOf[ActorWithArgs], "arg") // нет поддержки `value class arguments`
```

Второй вариант показывает, как передать аргументы конструктора создаваемому Актору, но его следует использовать только 
вне участников, как описано ниже.

В последней строке показана возможность передавать аргументы конструктора независимо от используемого им контекста. 
Наличие конструктора соответствия проверяется во время построения объекта Props, в результате чего возникает исключение 
`IllegalArgumentException`, если найдены конструкторы с отсутствием или множественным соответствием.

>Рекомендуемый подход к созданию Props актора не поддерживается для случаев, когда конструктор-актор принимает 
классы значений в качестве аргументов.

#### Опасные варианты

```scala
//  НЕ РЕКОМЕНДУЕТСЯ в рамках другого актора: призывает закрыть закрывающий класс
val props7 = Props(new MyActor)
```

Этот метод не рекомендуется использовать в рамках другого актора, потому что он поощряет закрытие охватывающей области, 
что приводит к несериализуемым `Props` и возможно условиям гонки (нарушая инкапсуляцию актора). С другой стороны, использование
 этого варианта на фабрике Props в сопутствующем объекте актора, как описано в «Рекомендуемой практике» ниже, полностью 
 прекрасное.

Для этих методов использовалось два варианта использования: передача аргументов конструктора актору, который решается 
недавно введенным методом `Props.apply(clazz, args)` выше или рекомендуемой практикой ниже, и созданием акторов «на месте»
 как анонимных классы. Последнее должно быть решено, вместо того, чтобы вместо этого использовать эти классы с именами
  классов (если они не объявлены в объекте верхнего уровня, тогда эта ссылка на экземпляр экземпляра должна быть 
  передана в качестве первого аргумента).
  
>Предупреждение!  Объявление одного актора в другом очень опасно и разрушает инкапсуляцию актора. Никогда не 
передавайте эту ссылку актору в реквизиты!  

#### Крайние случаи (Edge cases)
В создании актора есть два крайних случая:

* Актор с аргументами `AnyVal`.

```scala
case class MyValueClass(v: Int) extends AnyVal
```

```scala
class ValueActor(value: MyValueClass) extends Actor {
  def receive = {
    case multiplier: Long ⇒ sender() ! (value.v * multiplier)
  }
}
val valueClassProp = Props(classOf[ValueActor], MyValueClass(5)) // Unsupported
```

* Актор со значениями конструктора по умолчанию.

```scala
class DefaultValueActor(a: Int, b: Int = 5) extends Actor {
  def receive = {
    case x: Int ⇒ sender() ! ((a + x) * b)
  }
}

val defaultValueProp1 = Props(classOf[DefaultValueActor], 2.0) // Unsupported

class DefaultValueActor2(b: Int = 5) extends Actor {
  def receive = {
    case x: Int ⇒ sender() ! (x * b)
  }
}
val defaultValueProp2 = Props[DefaultValueActor2] // Unsupported
val defaultValueProp3 = Props(classOf[DefaultValueActor2]) // Unsupported
```

В обоих случаях исключение `IllegalArgumentException` будет брошено, из-за того что никакой конструктор соответствия не найден.

В следующем разделе объясняются рекомендуемые способы создания реквизита Актора таким образом, который одновременно 
защищает от этих крайних случаев.

#### Рекомендуемая практика
Это хорошая идея, чтобы предоставить фабричные методы на сопутствующем объекте каждого Актора, которые помогают 
поддерживать создание подходящих реквизитов как можно ближе к определению актора. Это также позволяет избежать ошибок, 
связанных с использованием метода `Props.apply(...)`, который принимает аргумент `by-name`, поскольку внутри 
объекта-компаньона данный блок кода не сохранит ссылку на свою охватывающую область:

```scala
object DemoActor {
  /**
    * Создайте реквизит для актора этого типа.
    *
    * @param magicNumber - Магическое число, которое нужно передать конструктору этого актора.
    * @ возвратите реквизит для создания этого актора, который затем может быть дополнительно настроен
    * (например, вызов `.withDispatcher ()` на нем)
   */
  def props(magicNumber: Int): Props = Props(new DemoActor(magicNumber))
}

class DemoActor(magicNumber: Int) extends Actor {
  def receive = {
    case x: Int ⇒ sender() ! (x + magicNumber)
  }
}

class SomeOtherActor extends Actor {
  // Props(new DemoActor(42)) не будет безопасным
  context.actorOf(DemoActor.props(42), "demo")
  // ...
}
```

Другая хорошая практика заключается в том, чтобы объявить, какие сообщения может получить Актор в сопутствующем 
объекте Актора, что облегчает понимание того, что он может получить:

```scala
object MyActor {
  case class Greeting(from: String)
  case object Goodbye
}
class MyActor extends Actor with ActorLogging {
  import MyActor._
  def receive = {
    case Greeting(greeter) ⇒ log.info(s"I was greeted by $greeter.")
    case Goodbye           ⇒ log.info("Someone said goodbye to me.")
  }
}
```

#### Создание акторов с реквизитом
Акторы создаются путем передачи экземпляра Props в заводский метод `actorOf`, который доступен в `ActorSystem` и `ActorContext`.

```scala
import akka.actor.ActorSystem

// ActorSystem - это тяжелый объект: создавайте только одно на все приложение
val system = ActorSystem("mySystem")
val myActor = system.actorOf(Props[MyActor], "myactor2")
```

Использование `ActorSystem` создаст игроков верхнего уровня, контролируемых действующим акторским актором, в то время как 
использование контекста актора создаст дочернего актора.

```scala
class FirstActor extends Actor {
  val child = context.actorOf(Props[MyActor], name = "myChild")
  def receive = {
    case x ⇒ sender() ! x
  }
}
```

Рекомендуется создавать иерархию детей, внуков и т.д., чтобы она соответствовала логической структуре обработки отказа 
приложения.

Вызов `actorOf` возвращает экземпляр `ActorRef`. Это дескриптор экземпляра актора и единственный способ взаимодействия 
с ним. `ActorRef` неизменен (` immutable`) и имеет отношения «один к одному» с представленным им Актором. `ActorRef`
 также сериализуется и поддерживается сетью. Это означает, что вы можете сериализовать его, отправить его по проводу и 
 использовать его на удаленном хосте, и он все равно будет представлять одного и того же Актора на исходном узле по всей сети.

Параметр имени является необязательным, но вы должны предпочтительно назвать своих участников, поскольку это используется
 в сообщениях журнала и для идентификации участников. Имя не должно быть пустым или начинаться с $, но оно может содержать
  URL-кодированные символы (например, `%20` для пробела). Если данное имя уже используется другим дочерним элементом 
  для одного и того же родителя, генерируется `InvalidActorNameException`.

Акторы автоматически запускаются асинхронно при создании.

#### Классы значений как аргументы конструктора
Рекомендуемый способ создания экземпляров акторских реквизитов использует отражение во время выполнения, чтобы определить
 правильный вызывающий конструктор, и из-за технических ограничений не поддерживается, когда указанный конструктор 
 принимает аргументы, которые являются классами значений. В этих случаях вы должны либо распаковать аргументы, либо 
 создать реквизит, вызвав конструктор вручную:

```scala
class Argument(val value: String) extends AnyVal
class ValueClassActor(arg: Argument) extends Actor {
  def receive = { case _ ⇒ () }
}

object ValueClassActor {
  def props1(arg: Argument) = Props(classOf[ValueClassActor], arg) // fails at runtime
  def props2(arg: Argument) = Props(classOf[ValueClassActor], arg.value) // ok
  def props3(arg: Argument) = Props(new ValueClassActor(arg)) // ok
}
```

#### Внедрение зависимости (Dependency Injection)
Если у вашего актора есть конструктор, который принимает параметры, то они также должны быть частью реквизита (Props), как 
описано выше. Но бывают случаи, когда должен использоваться заводский метод, например, когда фактические аргументы 
конструктора определяются каркасом внедрения зависимостей.

```scala
import akka.actor.IndirectActorProducer

class DependencyInjector(applicationContext: AnyRef, beanName: String)
  extends IndirectActorProducer {

  override def actorClass = classOf[Actor]
  override def produce =
    new Echo(beanName)

  def this(beanName: String) = this("", beanName)
}

val actorRef = system.actorOf(
  Props(classOf[DependencyInjector], applicationContext, "hello"),
  "helloBean")
```

>Предупреждение! Иногда у вас может возникнуть соблазн предложить `IndirectActorProducer`, который всегда возвращает тот
 же экземпляр, например. используя `lazy val`. Это не поддерживается, поскольку это противоречит смыслу рестарта 
 актора. При использовании инверсии зависимостей, акторские бины НЕ ДОЛЖНЫ иметь синглтон скоуп.


#### Inbox
При написании кода вне участников, который должен общаться с участниками, шаблон запроса (`ask` паттерн) может быть решением 
(см. ниже), но есть две вещи, которые он не может сделать: получение нескольких ответов (например, подписка на `ActorRef`
 на службу уведомлений) и просмотр других жизненный цикл акторов. Для этих целей есть класс `Inbox`:
 
 ```scala
implicit val i = inbox()
echo ! "hello"
i.receive() should ===("hello")
```

Существует неявное преобразование из Inbox в ссылку «Актор», что означает, что в этом примере ссылка отправителя будет 
таковой у субъекта, скрытого в Inbox. Это позволяет получить ответ на последней строке. Наблюдение за актором довольно просто:

```scala
val target = // some actor
val i = inbox()
i watch target
```

### Актор API
Характористика Актора определяет только один абстрактный метод, упомянутый выше, который реализует поведение актора.
Если текущее поведение актора не соответствует принятому сообщению, вызывается необработанное сообщение, которое по 
умолчанию публикует сообщение `akka.actor.UnhandledMessage(message, sender, recipient)` в потоке событий акторской 
системы (задан элемент конфигурации `akka.actor.debug.unhandled` чтобы они были преобразованы в фактические сообщения отладки).

Кроме того, он предлагает:

* `self` ссылка на ActorRef актора
* `sender` ссылки отправителя Актор последнего полученного сообщения
* `supervisorStrategy` пользовательское переопределяемое определение - стратегия, используемая для наблюдения за 
дочерними субъектами

Эта стратегия обычно объявляется внутри актора, чтобы иметь доступ к внутреннему состоянию актора в функции решателя: 
поскольку отказ сообщается как сообщение, отправленное супервизору и обрабатывается как другие сообщения (хотя и вне 
нормального поведения), все значения и доступны переменные внутри актора, а также ссылка отправителя (которая будет 
являться непосредственным ребенком, сообщающим об ошибке, если исходный сбой произошел в отдаленном потомке, он 
по-прежнему регистрируется на одном уровне за раз).

* `context` предоставляет контекстуальную информацию для актора и текущего сообщения, например:
   * фабричные методы создания дочерних акторов (`actorOf`)
   * система, в которой актор принадлежит
   * родительский руководитель
   * контролируемые дети
   * мониторинг жизненного цикла
   * стека поведения `hotswap`

Вы можете импортировать элементы в контексте, чтобы избежать префикса доступа с помощью контекста.

```scala
class FirstActor extends Actor {
  import context._
  val myActor = actorOf(Props[MyActor], name = "myactor")
  def receive = {
    case x ⇒ myActor ! x
  }
}
```

Оставшиеся видимые методы представляют собой перехватываемые пользователем хуки жизненного цикла, которые описаны ниже:

```scala
def preStart(): Unit = ()

def postStop(): Unit = ()

def preRestart(reason: Throwable, message: Option[Any]): Unit = {
  context.children foreach { child ⇒
    context.unwatch(child)
    context.stop(child)
  }
  postStop()
}

def postRestart(reason: Throwable): Unit = {
  preStart()
}
```
Представления, показанные выше, являются значениями по умолчанию, предоставляемыми признаком Actor.

### Жизненный цикл актора

![alt text](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/images/actor/actor_lifecycle.png "actor_lifecycle")

Путь в акторской системе представляет собой «место», которое может занимать живой актор. Первоначально (кроме системных 
инициализированных участников) путь пуст. Когда вызывается `actorOf()`, он присваивает воплощение актора, описанного 
переданными `Props`, данному пути. Воплощение актора идентифицируется по пути и UID.

Стоит отметить разницу между:

* запустить снова
* остановить, а затем воссоздать актора

Повторный запуск заменяет экземпляр Actor, определенный в Props, но воплощение, и поэтому UID остается неизменным. 
Пока воплощение будет таким же, вы можете продолжать использовать тот же `ActorRef`. Перезапуск управляется `Стратегией 
надзора` родительского актора.

Жизненный цикл воплощения заканчивается, когда актор остановлен. В этот момент вызываются соответствующие события 
жизненного цикла, и наблюдающие участники уведомляются о завершении. После того, как воплощение будет остановлено, 
путь можно снова использовать повторно, создав актора с `actorOf()`. В этом случае имя нового воплощения будет таким же, 
как и предыдущее, но UID будут отличаться. Актор может быть остановлен самим актором, другим актором или `ActorSystem`.

>Важно отметить, что Акторы не останавливаются автоматически, когда больше не ссылаются, каждый созданный Актор также 
должен быть явно уничтожен. Единственное упрощение состоит в том, что остановка родительского Актора также рекурсивно 
останавливает всех дочерних Акторов, созданных этим родителем.

`ActorRef` всегда представляет собой воплощение (путь и UID), а не только определенный путь. Поэтому, если актор 
остановлен и создается новый с тем же именем, ActorRef из старого воплощения не будет указывать на новый.

`ActorSelection`, с другой стороны, указывает на путь (или несколько путей, если используются подстановочные знаки), и 
совершенно не обращает внимания на то, что в настоящее время оно занимает его воплощение. По этой причине нельзя наблюдать
 за `ActorSelection`. Можно разрешить `ActorRef` текущего воплощения, живущего под путём, отправив сообщение `Identify` на 
 `ActorSelection`, на который будет отправлен ответ `ActorIdentity`, содержащий правильную ссылку. 
 Это также можно сделать с помощью метода resolveOne для `ActorSelection`, который возвращает будущее соответствующего `ActorRef`.

#### Мониторинг жизненного цикла (DeathWatch)
Чтобы быть уведомленным о прекращении действия другого актора (т.е. навсегда, а не на временном сбое и перезапуске), 
актор может зарегистрироваться для получения завершенного сообщения, отправленного другим актором после прекращения 
действия. Эта услуга предоставляется компонентом `DeathWatch` системы акторов.

Регистрация монитора проста:
```scala
import akka.actor.{ Actor, Props, Terminated }

class WatchActor extends Actor {
  val child = context.actorOf(Props.empty, "child")
  context.watch(child) // <-- this is the only call needed for registration
  var lastSender = context.system.deadLetters

  def receive = {
    case "kill" ⇒
      context.stop(child); lastSender = sender()
    case Terminated(`child`) ⇒ lastSender ! "finished"
  }
}
```

Следует отметить, что завершенное (`Terminated`) сообщение генерируется независимо от порядка, в котором происходит 
регистрация и завершение. В частности, наблюдающий актор получит сообщение с прекращением действия, даже если наблюдаемый
 актор уже был прекращен во время регистрации.

Регистрация нескольких раз не обязательно приводит к генерации нескольких сообщений, но нет гарантии, что получено 
только одно такое сообщение: если завершение наблюдаемого актора сгенерировало и поставило в очередь сообщение, а 
другая регистрация будет выполнена до того, как это сообщение будет обрабатывается, то второе сообщение будет поставлено
 в очередь, так как регистрация для мониторинга уже прекращенного участника приводит к немедленному генерации завершенного
  сообщения.

Также можно отменить регистрацию, чтобы наблюдать за живостью другого актора, используя `context.unwatch(target)`. Это 
работает даже в том случае, если завершенное сообщение уже помещено в очередь в почтовом ящике; после вызова `unwatch`
 никакого завершенного сообщения для этого актора не будет обработано больше.

#### Хук старта (Start Hook)
Сразу после запуска актора вызывается его метод `preStart`.
```scala
override def preStart(): Unit = {
  child = context.actorOf(Props[MyActor], "child")
}
```

Этот метод вызывается, когда актор сначала создается. Во время перезапуска он вызывается реализацией по умолчанию
 `postRestart` по умолчанию, что означает, что, переопределяя этот метод, вы можете выбрать, будет ли код инициализации
  в этом методе вызываться только ровно один раз для этого актора или для каждого перезапуска. Код инициализации, 
  который является частью конструктора актора, всегда вызывается, когда создается экземпляр класса актора, который 
  происходит при каждом перезапуске.

#### Хуки перезапуска (Restart Hooks)
Все участники контролируются, т.е. связаны с другим игроком с стратегией обработки ошибок. Акторы могут быть перезапущены
 в случае возникновения исключения при обработке сообщения. Этот перезапуск включает в себя перечисленные выше крючки:

1. Старому актору сообщается, вызывая `preRestart` с исключением, вызвавшим перезапуск, и сообщение, вызвавшее это 
исключение; последний может быть `None`, если перезапуск не был вызван обработкой сообщения, например. когда супервизор 
не улавливает исключение и перезапускается в свою очередь своим супервизором или если актор перезапускается из-за сбоя 
брата или сестры. Если сообщение доступно, то отправитель этого сообщения также доступен обычным способом (т.е. путем 
вызова `sender`). Этот метод является лучшим местом для очистки, подготовки передачи к экземпляру нового актора и т.д.
 по умолчанию он останавливает всех детей и вызывает `postStop`. 
2. Первоначальная фабрика из вызова `actorOf` используется для создания нового экземпляра. 
3. Метод postRestart нового участника вызывается с исключением, вызвавшим перезапуск. По умолчанию вызывается `preStart`, 
как и в обычном случае запуска.

Актор перезапускает замену только фактического объекта актора; при повторном запуске содержимое почтового ящика не будет
 затронуто, поэтому обработка сообщений возобновится после возврата к клику postRestart. Сообщение, вызвавшее исключение,
  не будет получено повторно. Любое сообщение, отправленное актору во время его перезапуска, будет помещено в очередь 
  на его почтовый ящик, как обычно.

>Имейте в виду, что упорядочение уведомлений об отказах относительно сообщений пользователя не является детерминированным.
 В частности, родитель может перезагрузить свой дочерний элемент до того, как он обработает последние сообщения, 
 отправленные дочерним элементом до сбоя.
 
#### Хук остановки (Stop Hook)
После остановки актора вызывается его хук `postStop`, который может быть использован, например. за отмену регистрации
 этого участника из других служб. Этот хук гарантированно будет запущен после того, как очередь сообщений будет 
 отключена для этого актора, то есть сообщения, отправленные остановленному игроку, будут перенаправлены на 
 `deadLetters` системы `ActorSystem`.
 
### Идентификация акторов с помощью выбора актора
Как описано в `Actor References`, `Paths and Addresses`, **каждый актор имеет уникальный логический путь**, который 
получается, следуя цепочке участников от дочернего к родительскому до достижения корня системы акторов и **имеет 
физический путь**, который может отличаться если в цепочку контроля входят любые удаленные супервизоры. Эти пути 
используются системой для поиска акторов. Например, когда получено удаленное сообщение и выполняется поиск получателя, 
но они также полезны более непосредственно: участники могут искать других участников, указывая абсолютные или 
относительные пути - логические или физические - и получать обратно `ActorSelection` с результатом:

```scala
// будет искать этот абсолютный путь
context.actorSelection("/user/serviceA/aggregator")
// будет искать родного брата под тем же супервизором
context.actorSelection("../joe")
```

>Всегда лучше общаться с другими Акторами, используя их ActorRef вместо того, чтобы полагаться на ActorSelection. 

Исключения:
1. отправка сообщений с использованием средства доставки «По крайней мере один раз»
2. инициирование первого контакта с удаленной системой. 

Во всех других случаях `ActorRefs` могут быть предоставлены во время создания или инициализации Актора, передачи их от 
родителя к ребенку или введения Акторов, отправив свои ActorRefs другим Акторам в сообщениях.

Поставляемый путь анализируется как `java.net.URI`, что означает, что он разделен на **`/`** на элементы пути. Если 
путь начинается с `/`, он является абсолютным, и поиск начинается с корневого опекуна (который является родительским 
элементом `/user`); иначе он начинается с текущего участника. Если элемент пути равен **`..`**, поиск будет идти 
«вверх» к супервизору текущего перемещаемого актора, иначе он будет «вниз» к названному ребенку. Следует отметить, что
 здесь на дорожках актора всегда подразумевается логическая структура, то есть супервизор.

Элементы пути выбора актора могут содержать шаблоны подстановочных знаков, позволяющие передавать сообщения в этот раздел:

```scala
// будем искать все[ детям serviceB с именами, начинающимися с `worker`
context.actorSelection("/user/serviceB/worker*")
// будет искать всех братьев и сестер под тем же супервизором
context.actorSelection("../*")
```

Сообщения могут быть отправлены с помощью `ActorSelection`, и при передаче каждого сообщения просматривается путь 
`ActorSelection`. Если выбор не соответствует ни одному актору, сообщение будет удалено.

Чтобы приобрести `ActorRef` для выбора `ActorSelection`, вам нужно отправить сообщение на выбор и использовать ссылку
 отправителя `sender()` ответа от актора. Существует встроенное сообщение `Identify`, которое все Акторы поймут и 
 автоматически ответят сообщением `ActorIdentity`, содержащим `ActorRef`. Это сообщение обрабатывается специально 
 субъектами, которые пересекаются в том смысле, что если конкретный поиск имени терпит неудачу (т.е. элемент пути без 
 подстановочных знаков не соответствует активному актору), то генерируется отрицательный результат. Обратите внимание, 
 что это не означает, что доставка этого ответа гарантирована, это все равно нормальное сообщение.

```scala
import akka.actor.{ Actor, Props, Identify, ActorIdentity, Terminated }

class Follower extends Actor {
  val identifyId = 1
  context.actorSelection("/user/another") ! Identify(identifyId)

  def receive = {
    case ActorIdentity(`identifyId`, Some(ref)) ⇒
      context.watch(ref)
      context.become(active(ref))
    case ActorIdentity(`identifyId`, None) ⇒ context.stop(self)

  }

  def active(another: ActorRef): Actor.Receive = {
    case Terminated(`another`) ⇒ context.stop(self)
  }
}
```

Вы также можете приобрести `ActorRef` для выбора `ActorSelection` с помощью метода `resolveOne` для выбора `ActorSelection`. 
Он возвращает будущее соответствующего `ActorRef`, если такой актор существует. Он завершается сбоем 
`akka.actor.ActorNotFound`, если такого участника нет или идентификация не завершена в течение установленного таймаута.

Адреса удаленных акторов также могут быть просмотрены, если удаленный доступ включен:

```scala
context.actorSelection("akka.tcp://app@otherhost:1234/user/serviceB")
```

### Сообщения и неизменяемость (Messages and immutability)

>Сообщения могут быть любыми объектами, но должны быть неизменными. Scala не может обеспечить неизменность (пока), так 
что это должно быть по соглашению. Примитивы типа String, Int, Boolean всегда неизменны. Помимо этого рекомендуется 
использовать классы Case Scala, которые являются неизменными (если вы явно не раскрываете состояние) и отлично 
справляются с сопоставлением шаблонов со стороны приемника.

Вот пример:

```scala
case class User(name: String)
case class Register(user: User)

val user    = User("Mike")
val message = Register(user)
```

### Отправка сообщений
Сообщения отправляются актору одним из следующих способов:

* **`!`** означает «огонь и забыть», например. отправить сообщение асинхронно и немедленно вернуться. 
Также известен как **`tell`**.
* **`?`** отправляет сообщение асинхронно и возвращает `Future`, представляющее возможный ответ. Также известен как **`ask`**.
Порядок сообщений гарантируется для каждого отправителя.

>Есть последствия для производительности использования `ask`, потому что что-то нужно отслеживать, когда оно истекает, 
должно быть что-то, что превращает `Promise` в `ActorRef`, и оно также должно быть доступно через удаленный доступ. 
Поэтому всегда предпочитайте `tell` для лучшей производительности, а `ask` если нет другой возможности.

#### Tell: Fire-forget
Это предпочтительный способ отправки сообщений. Нет блокировки, ожидающей сообщения. Это дает наилучшие характористики 
параллелизма и масштабируемости.

```scala
actorRef ! message
```

Если он вызван изнутри Актора, ссылка на отправку актора будет неявно передаваться вместе с сообщением и доступна 
получающему Актору в его методе `sender(): ActorRef`. Целевой актор может использовать это, чтобы ответить первоначальному
 отправителю, используя `sender() ! replyMsg`.

Если он вызван из экземпляра, который не является Актором, отправитель по умолчанию будет `deadLetters` ссылкой актора.

#### Ask: Send-And-Receive-Future
В шаблоне запроса участвуют как акторы, так и фьючерсы, поэтому он предлагается как шаблон использования, а не метод на ActorRef:

```scala
import akka.pattern.{ ask, pipe }
import system.dispatcher // The ExecutionContext that will be used
final case class Result(x: Int, s: String, d: Double)
case object Request

implicit val timeout = Timeout(5 seconds)  // needed for `?` below

val f: Future[Result] =
  for {
    x ← ask(actorA, Request).mapTo[Int]    // call pattern directly
    s ← (actorB ask Request).mapTo[String] // call by implicit conversion
    d ← (actorC ? Request).mapTo[Double]   // call by symbolic name
  } yield Result(x, s, d)

f pipeTo actorD // .. or ..
pipe(f) to actorD
```

Этот пример демонстрирует `ask` вместе с шаблоном `pipeTo` на фьючерсах, потому что это, вероятно, будет общей 
комбинацией. Обратите внимание, что все вышеперечисленное полностью не блокируется и асинхронно: `ask` производит `Future`,
 три из которых состоят из нового будущего, используя `for-comprehension`, а затем `pipeTo` устанавливает обработчик 
 `onComplete` на Future, чтобы повлиять на представление агрегированный результат для другого актора.

Использование `ask` отправит сообщение получающему актору, как и с `tell`, и принимающий актор должен ответить 
`sender() ! reply`, чтобы завершить возвращенное будущее со значением. Операция запроса включает создание внутреннего 
субъекта для обработки этого ответа, который должен иметь таймаут, после которого он уничтожается, чтобы не утечка 
ресурсов; см. ниже.

>Чтобы завершить будущее с исключением, вам необходимо отправить отправителю сообщение `akka.actor.Status.Failure`. 
Это не делается автоматически, когда актор выдает исключение при обработке сообщения. 
Обратите внимание, что `scala.util.Failure` и `scala.util.Success` - это подтипы `Try`,  не обрабатываются специально и 
будут заполнять запрос `Future` с заданным значением - только сообщения `akka.actor.Status` обрабатываются специально 
шаблоном запроса.

```scala
try {
  val result = operation()
  sender() ! result
} catch {
  case e: Exception ⇒
    sender() ! akka.actor.Status.Failure(e)
    throw e
}
```
Если актор не завершит будущее, он истечет после периода ожидания, завершив его с помощью `AskTimeoutException`. 
Тайм-аут берется из одного из следующих мест в порядке приоритета:

1. явно заданный тайм-аут, как в:
```scala
import scala.concurrent.duration._
import akka.pattern.ask
val future = myActor.ask("hello")(5 seconds)
```
2. неявный аргумент (`implicit argument`) типа `akka.util.Timeout`, например .
```scala
import scala.concurrent.duration._
import akka.util.Timeout
import akka.pattern.ask
implicit val timeout = Timeout(5 seconds)
val future = myActor ? "hello"
```

Методы `onComplete`, `onSuccess` или `onFailure` будущего могут использоваться для регистрации обратного вызова для 
получения уведомления, когда будущее завершается, что дает вам возможность избежать блокировки.

>При использовании будущих обратных вызовов, таких как `onComplete`, `onSuccess` или `onFailure`, внутри акторов вам 
необходимо избегать закрытия над ссылкой содержащего актора, то есть не вызывать методы или доступ к изменяемому 
состоянию на окружающем акторе из обратного вызова. Это нарушит инкапсуляцию актора и может привести к ошибкам 
синхронизации и условиям гонки, потому что обратный вызов будет запланирован одновременно с окружающим актором. 
К сожалению, пока не удается обнаружить эти незаконные обращения во время компиляции. 

### Получение сообщений
Актор должен реализовать метод `receive` для приема сообщений:

```scala
type Receive = PartialFunction[Any, Unit]

def receive: Actor.Receive
```

Этот метод возвращает `PartialFunction`, например. предложение `match / case`, в котором сообщение может быть сопоставлено
 с различными предложениями case, используя сопоставление шаблонов Scala. Вот пример:
 
```scala
import akka.actor.Actor
import akka.actor.Props
import akka.event.Logging

class MyActor extends Actor {
  val log = Logging(context.system, this)

  def receive = {
    case "test" ⇒ log.info("received test")
    case _      ⇒ log.info("received unknown message")
  }
}
```
### Ответ на сообщения

Если вы хотите иметь дескриптор для ответа на сообщение, вы можете использовать `sender()`, который дает вам `ActorRef`. 
Вы можете ответить, отправив этому ActorRef с `sender() ! replyMsg`. Вы также можете сохранить ActorRef для ответа 
позже или передать другим участникам. Если отправителя нет (сообщение было отправлено без актора или будущего контекста),
 то отправитель по умолчанию ссылается на «мертвое письмо».
 
```scala
sender() ! x // ответы будут переданы этому актору
```

### Тайм-аут приема
`ActorContext setReceiveTimeout` определяет тайм-аут бездействия, после которого запускается отправка сообщения 
`ReceiveTimeout`. Когда указано, функция приема должна иметь возможность обрабатывать сообщение `akka.actor.ReceiveTimeout`.
 1 миллисекунда является минимальным временем ожидания.

Обратите внимание, что тайм-аут приема может срабатывать и выдавать сообщение `ReceiveTimeout` сразу после того, как 
другое сообщение было выставлено в очередь; следовательно, не гарантируется, что после приема тайм-аута приема должен 
был быть заранее установленный период времени, как он сконфигурирован с помощью этого метода.

После установки тайм-аут приема остается в силе (т.е. продолжает многократно срабатывать после периодов бездействия). 
Перейдите в `Duration.Undeined` для отключения этой функции.

```scala
import akka.actor.ReceiveTimeout
import scala.concurrent.duration._
class MyActor extends Actor {
  // To set an initial delay
  context.setReceiveTimeout(30 milliseconds)
  def receive = {
    case "Hello" ⇒
      // To set in a response to a message
      context.setReceiveTimeout(100 milliseconds)
    case ReceiveTimeout ⇒
      // To turn it off
      context.setReceiveTimeout(Duration.Undefined)
      throw new RuntimeException("Receive timed out")
  }
}
```

Сообщения, отмеченные `NotInfluenceReceiveTimeout`, не будут сбрасывать таймер. Это может быть полезно, когда 
`ReceiveTimeout` должен быть запущен из-за внешнего бездействия, но не под влиянием внутренней активности, например, 
запланированных сообщений шедулера.

### Таймеры, запланированные сообщения
Сообщения могут быть запланированы для отправки с помощью планировщика напрямую, но при 
планировании периодических или отдельных сообщений в акторе самому себе удобнее и безопаснее использовать поддержку 
именованных таймеров. Жизненный цикл запланированных сообщений может быть сложен для управления, когда актор перезагружается
 и об этом заботятся таймеры.
 
```scala
import scala.concurrent.duration._

import akka.actor.Actor
import akka.actor.Timers

object MyActor {
  private case object TickKey
  private case object FirstTick
  private case object Tick
}

class MyActor extends Actor with Timers {
  import MyActor._
  timers.startSingleTimer(TickKey, FirstTick, 500.millis)

  def receive = {
    case FirstTick ⇒
      // сделай что-нибудь полезное здесь
      timers.startPeriodicTimer(TickKey, Tick, 1.second)
    case Tick ⇒
      //сделай что-нибудь полезное здесь
  }
}
```

Каждый таймер имеет ключ и может быть заменен или отменен. Гарантируется, что **сообщение из предыдущего воплощения 
таймера с тем же ключом не получено**, даже если оно уже может быть установлено в почтовом ящике после его отмены или 
запускается новый таймер.

Таймеры привязаны к жизненному циклу актора, который владеет им, и поэтому автоматически отменяется при его перезапуске
 или остановке. Обратите внимание, что `TimerScheduler` не является потокобезопасным, т.е. он должен использоваться 
 только в пределах субъекта, владеющего им.
 
### Остановка акторов
Акторы останавливаются путем вызова метода остановки `ActorRefFactory`, то есть `ActorContext` или `ActorSystem`. Как правило,
 этот контекст используется для остановки самого актора или дочерних участников и системы для остановки игроков верхнего
  уровня. Фактическое завершение актора выполняется асинхронно, т.е. остановка может вернуться до остановки актора.
 
```scala
class MyActor extends Actor {

  val child: ActorRef = ???

  def receive = {
    case "interrupt-child" ⇒
      context stop child

    case "done" ⇒
      context stop self
  }

}
```

Обработка текущего сообщения, если оно есть, будет продолжаться до того, как актор остановится, но дополнительные 
сообщения в почтовом ящике не будут обработаны. По умолчанию эти сообщения отправляются в `deadLetters` из `ActorSystem`,
 но это зависит от реализации почтового ящика.

Прекращение действия актора происходит в два этапа: 
* сначала актор приостанавливает обработку своего почтового ящика и отправляет команду останвки всем своим дочерним 
элементам, затем он продолжает обрабатывать внутренние уведомления 
о завершении от своих дочерних элементов до тех пор, пока последний не уйдет, окончательно завершая себя (вызывая 
`postStop` , демпинг почтового ящика, публикация завершена на `DeathWatch`, сообщая своему руководителю). Эта процедура 
гарантирует, что поддеревья акторской системы закончатся упорядоченным образом, распространяя команду останвки на 
листья и собирая их подтверждение обратно остановленному супервизору. Если один из участников не отвечает (т.е. 
обрабатывает сообщение в течение длительных периодов времени и, следовательно, не принимает команду останвки), весь 
этот процесс будет зависеть.

* после `ActorSystem.terminate()`, акторы системного стража будут остановлены, и вышеупомянутый процесс обеспечит 
правильное завершение всей системы.

Хук `postStop()` вызывается после того, как актор полностью остановлен. Это позволяет очистить ресурсы:

```scala
override def postStop(): Unit =  ()

```
>Поскольку остановка актора является асинхронной, вы не можете сразу использовать имя только что остановленного 
ребенка; это приведет к исключению `InvalidActorNameException`. Вместо этого `watch()` завершающий актор и 
создавайте его замену в ответ на сообщение `Terminated`, которое в конечном итоге поступит.

#### PoisonPill
Вы также можете отправить актору сообщение `akka.actor.PoisonPill`, которое остановит актора при обработке сообщения.
 `PoisonPill` помещается в очередь как обычные сообщения и будет обрабатываться после сообщений, которые уже были 
 поставлены в очередь в почтовом ящике.
 
```scala
watch(victim)
victim ! PoisonPill
```

#### Убийство актора
Вы также можете «убить» актора, отправив `Kill` сообщение. В отличие от `PoisonPill` это заставит актора выбросить 
исключение `ActorKilledException`, вызывающий сбой. Актор приостанавливает операцию, и его руководителю будет задан
 вопрос о том, как справиться с этим сбоем, что может означать возобновление действия актора, перезапуск или полное
  его завершение. 
  
Используйте `Kill` следующим образом:

```scala
context.watch(жертва) // наблюдайте, как Актор получает сообщение о завершении работы после его смерти

жертва ! Kill

expectMsgPF(hint = "ожидание завершения жертвы") {
  case Terminated(v) if v == victim ⇒ v // Актор действительно прекратил
}
```

Не рекомендуется чрезмерно полагаться на `PoisonPill` или `Kill` при разработке взаимодействия с вашим актором, 
так как часто возникает сообщение об уровне протокола, такое как `PleaseCleanupAndStop` и актор знает, как обращаться с 
ним. Сообщения существуют для того, чтобы остановить акторов, над созданием которых вы не имеете контроля.

#### Изящная остановка (Graceful Stop)
`gracefulStop` полезен, если вам нужно ждать завершения или составить упорядоченное завершение нескольких участников:

```scala
import akka.pattern.gracefulStop
import scala.concurrent.Await

try {
  val stopped: Future[Boolean] = gracefulStop(actorRef, 5 seconds, Manager.Shutdown)
  Await.result(stopped, 6 seconds)
  // актор был остановлен
} catch {
  // актор не был остановлен в течение 5 секунд
  case e: akka.pattern.AskTimeoutException ⇒
}
```
Когда `gracefulStop()` успешно возвращается, будет выполняться хук `postStop ()` актора: существует происходит-перед 
краем между концом  `postStop()` и возвратом `gracefulStop()`.

В приведенном выше примере пользовательское `Manager.Shutdown` сообщению отправляется целевому актору, для запуска 
процесса остановки актора. Вы можете использовать `PoisonPill` для этого, но тогда у вас есть ограниченные
 возможности для взаимодействия с другими игроками, прежде чем остановить целевого актора. Простые задачи очистки можно
  обрабатывать в `postStop`.
  
>Имейте в виду, что остановка субъекта и отмена регистрации его имени являются отдельными событиями, которые происходят 
асинхронно друг от друга. Поэтому может оказаться, что вы найдете имя, которое все еще используется после возвращения
 `gracefulStop()`. Чтобы гарантировать надлежащую отмену регистрации, повторно используйте только имена из супервизора,
  которым вы управляете, и только в ответ на завершенное сообщение, т. е. не для субъектов верхнего уровня.

#### Скоординированное завершение работы
Существует расширение с именем `CoordinatedShutdown`, которое остановит определенные участники и службы в определенном
 порядке и выполнит зарегистрированные задачи во время процесса останова.

Порядок фаз выключения определяется в конфигурации `akka.coordinated-shutdown.phases`. Фазы по умолчанию определяются как:

```yaml
# CoordinatedShutdown включен по умолчанию и будет запускать задачи, которые
# добавляются к этим этапам отдельными модулями Akka и пользовательской логикой.
#
# Фазы упорядочены как DAG, определяя зависимости между фазами
#, чтобы убедиться, что задачи выключения выполняются в правильном порядке.
#
# Обычно задачи пользователя относятся к первым этапам, но могут быть использованы
# случаях, когда вы захотите подключиться к новым этапам или зарегистрировать задачи позже
# DAG.
#
# Каждая фаза определяется как именованный конфигурационный раздел с
# следующие дополнительные свойства:
# - timeout = 15s: переопределить тайм-аут по умолчанию для этой фазы.
# - recover = off: Если фаза не завершена, завершение работы прерывается
#                  и зависящие фазы не будут выполнены.
# - enabled = off: пропустить все задания, зарегистрированные на этом этапе. Не использовать
#                  это, чтобы отключить фазы, если вы не уверены, что
#                  последствия есть. Многие из встроенных задач зависят от других задач
#                  был выполнен на более ранних этапах и может сломаться, если они отключены.
# depend-on = []: Запустить фазу после данных фаз
phases {

    # Первая предварительно определенная фаза, к которой приложения могут добавлять задачи.
    # Обратите внимание, что в приложении может быть добавлено больше фаз
    # путем переопределения этой фазы с дополнительным
    # зависит от.
  before-service-unbind {
  }

    # Прекратить прием новых входящих соединений.
    # Здесь вы можете регистрировать задачи, которые заставляют сервер перестать принимать новые соединения. Уже
    # Установленные соединения должны быть разрешены для продолжения и завершения, если это возможно.
  service-unbind {
    depends-on = [before-service-unbind]
  }

   # Подождите, пока выполняемые запросы не будут завершены.
   # Здесь вы регистрируете задачи, которые будут ждать завершения установленных соединений, потенциально
   # также сначала сказал им, что пришло время закрыть.
  service-requests-done {
    depends-on = [service-unbind]
  }

   # Окончательное завершение конечных точек обслуживания.
   # Здесь вы должны добавить задачи, которые принудительно уничтожают соединения, которые все еще существуют.
  service-stop {
    depends-on = [service-requests-done]
  }

   # Фаза для пользовательских задач приложения, которые должны выполняться
   # после выключения службы и до выключения кластера.
  before-cluster-shutdown {
    depends-on = [service-stop]
  }

  # Изящное закрытие кластерных областей.
  # Этот этап не предназначен для добавления пользователями задач.
  cluster-sharding-shutdown-region {
    timeout = 10 s
    depends-on = [before-cluster-shutdown]
  }

  # Извлечь команду leave для узла, который отключается.
  # Этот этап не предназначен для добавления пользователями задач.
  cluster-leave {
    depends-on = [cluster-sharding-shutdown-region]
  }

  # Выключение кластеров
  # Это делается как можно позже, чтобы разрешить выключение зоны осколков в
  # этап «фаза кластера-осколка-обрыва» для завершения до закрытия координатора осколков.
  # Этот этап не предназначен для добавления пользователями задач.
  cluster-exiting {
    timeout = 10 s
    depends-on = [cluster-leave]
  }

   # Дождитесь завершения завершения
   # Этот этап не предназначен для добавления пользователями задач.
  cluster-exiting-done {
    depends-on = [cluster-exiting]
  }

   # Фаза для пользовательских задач приложения, которые должны выполняться
   # после выключения кластера и до завершения действия ActorSystem.
  cluster-shutdown {
    depends-on = [cluster-exiting-done]
  }

   # Фаза для пользовательских задач приложения, которые должны выполняться
   # после выключения кластера и до завершения действия ActorSystem.
  before-actor-system-terminate {
    depends-on = [cluster-shutdown]
  }

   # Последняя фаза. См. Выше terminate-actor-system и exit-jvm.
   # Не добавляйте фазы, которые зависят от этой фазы, потому что
   # диспетчер и планировщик ActorSystem отключены.
   # Этот этап не предназначен для добавления пользователями задач.
  actor-system-terminate {
    timeout = 10 s
    depends-on = [before-actor-system-terminate]
  }
}
```

В конфигурации приложения могут добавляться дополнительные фазы, если это необходимо, путем переопределения фазы с 
дополнительным зависящим от нее. В частности, фазы `before-service-unbind`, `before-cluster-shutdown` и 
`before-actor-system-terminate`  предназначены для конкретных этапов или задач приложения.

Фазы по умолчанию определяются в одном линейном порядке, но фазы можно упорядочить как `ориентированный ациклический граф 
(directed acyclic graph - DAG)`, определяя зависимости между фазами. Фазы упорядочены с топологическим типом `DAG`.

Задачи могут быть добавлены к фазе с:

```scala
CoordinatedShutdown(system).addTask(
  CoordinatedShutdown.PhaseBeforeServiceUnbind, "someTaskName") { () ⇒
    import akka.pattern.ask
    import system.dispatcher
    implicit val timeout = Timeout(5.seconds)
    (someActor ? "stop").map(_ ⇒ Done)
  }
```

Возвращаемое `Future[Done]` должно быть завершено, когда задача будет завершена. Параметр имени задачи используется 
только для отладки/логирования.

Задачи, добавленные к одной и той же фазе, выполняются параллельно без каких-либо предположений о заказе. Следующий 
этап не начнется, пока не будут завершены все задачи предыдущей фазы.

Если задачи не завершены в течение установленного таймаута, в любом случае будет запущен следующий этап. Можно 
настроить `recovery = off` на фазу, чтобы прервать оставшуюся часть процесса выключения, если задача завершилась неудачей
 или не завершилась в течение таймаута.

Задачи обычно должны регистрироваться как можно раньше после запуска системы. При выполнении скоординированных задач 
завершения, которые были зарегистрированы, будут выполняться, но задачи, которые добавляются слишком поздно, не будут
 выполняться.

Чтобы запустить скоординированный процесс выключения, вы можете вызвать запуск в расширении `CoordinatedShutdown`:

```scala
val done: Future[Done] = CoordinatedShutdown(system).run(CoordinatedShutdown.UnknownReason)
```

Безопасно вызывать метод `run` несколько раз. Он будет работать только один раз.

Это также означает, что `ActorSystem` будет прекращена на последнем этапе. По умолчанию JVM не принудительно 
останавливается (он будет остановлен, если все потоки не-демона будут завершены). Чтобы включить жесткий `System.exit`
 в качестве последнего действия, вы можете настроить:
 
 ```yaml
akka.coordinated-shutdown.exit-jvm = on
```

При использовании кластера Akka `CoordinatedShutdown` автоматически запускается, когда узел кластера видит себя как 
`Exiting` т. е. выход из другого узла вызовет процесс завершения работы на выходящем узле. Задачи для изящного 
ухода кластера, включая грациозное завершение кластеров и кластеров, автоматически добавляются при использовании
 Akka Cluster, т.е. запуск процесса останова также приведет к изящному увольнению, если он еще не выполняется.

По умолчанию команда `CoordinatedShutdown` будет выполняться, когда процесс JVM завершается, например. через 
сигнал `kill SIGTERM` (`SIGINT ctrl-c` не работает). Такое поведение можно отключить с помощью:

```yaml
akka.coordinated-shutdown.run-by-jvm-shutdown-hook=off
```

### Become/Unbecome
#### Обновить (Upgrade)
Akka поддерживает горячую настройку (`hotswapping`) цикла сообщений Actor во время выполнения (`runtime`):
 вызывается метод `context.become` изнутри актора. 
 
 Метод `become` принимакет `PartialFunction[Any, Unit]`, который реализует  новый обработчик сообщений. 
 Код hotswapped хранится в Стеке, который можно `поместить` и `достать` (`pushed/popped`).

>Обратите внимание, что актор вернется к своему первоначальному поведению при перезапуске его Супервизором.

Чтобы отключить поведение Actor, выполните следующие действия:

```scala
class HotSwapActor extends Actor {
  import context._
  def angry: Receive = {
    case "foo" ⇒ sender() ! "I am already angry?"
    case "bar" ⇒ become(happy)
  }

  def happy: Receive = {
    case "bar" ⇒ sender() ! "I am already happy :-)"
    case "foo" ⇒ become(angry)
  }

  def receive = {
    case "foo" ⇒ become(angry)
    case "bar" ⇒ become(happy)
  }
}
```

Этот вариант метода `become` полезен для разных вещей, например для реализации конечного автомата состояния (`FSM`).
 Он заменит текущее поведение (т.е. верхнюю часть стека поведения), что означает, что вы не используете `unbecome`,
  вместо этого всегда выполняется следующее поведение.

Другой способ использования `become` не заменяет, а добавляет в верхнюю часть стека поведения. В этом случае необходимо 
следить за тем, чтобы количество операций `pop` (то есть небезопасное) соответствовало числу `push` в конечном итоге, 
в противном случае это означает утечку памяти (поэтому это поведение не является дефолт).

```scala
case object Swap
class Swapper extends Actor {
  import context._
  val log = Logging(system, this)

  def receive = {
    case Swap ⇒
      log.info("Hi")
      become({
        case Swap ⇒
          log.info("Ho")
          unbecome() // сбрасываем последний 'become' (для веселья)
      }, discardOld = false) // добавляем сверху вместо замены
  }
}

object SwapperApp extends App {
  val system = ActorSystem("SwapperSystem")
  val swap = system.actorOf(Props[Swapper], name = "swapper")
  swap ! Swap // logs Hi
  swap ! Swap // logs Ho
  swap ! Swap // logs Hi
  swap ! Swap // logs Ho
  swap ! Swap // logs Hi
  swap ! Swap // logs Ho
}
```

### Stash
Типаж `Stash` позволяет актору временно сбрасывать сообщения, которые не могут или не должны обрабатываться с 
использованием текущего поведения актора. После изменения обработчика сообщения актора, то есть прямо перед вызовом 
`context.become` или `context.unbecome`, все скрытые сообщения могут быть «размотанными», тем самым добавляя их в 
почтовый ящик актора. Таким образом, скрытые сообщения могут обрабатываться в том же порядке, в каком они были получены
 изначально.
 
>Типаж `Stash` расширяет маркерный признак `RequiresMessageQueue[DequeBasedMessageQueueSemantics]`, который просит 
систему автоматически выбирать реализацию почтового ящика на основе `deque` для актора. Если вы хотите больше 
контролировать почтовый ящик.

```scala
import akka.actor.Stash
class ActorWithProtocol extends Actor with Stash {
  def receive = {
    case "open" ⇒
      unstashAll()
      context.become({
        case "write" ⇒ // do writing...
        case "close" ⇒
          unstashAll()
          context.unbecome()
        case msg ⇒ stash()
      }, discardOld = false) // складывать сверху вместо замены
    case msg ⇒ stash()
  }
}
```

Вызов `stash()` добавляет текущее сообщение (сообщение, которое последний получил актор) к типу актора. Обычно он 
вызывается при обработке случая по умолчанию в обработчике сообщения актора для печати сообщений, которые не 
обрабатываются другими случаями. Неправильно сбрасывать одно и то же сообщение дважды; для этого возникает исключение 
`IllegalStateException`. Копирование может также быть ограничено, и в этом случае вызов `stash()` может привести к 
нарушению емкости, что приводит к исключению `StashOverflowException.` Емкость сейфа может быть сконфигурирована с 
использованием настройки пропускной способности (`stash-capacity`) (Int) конфигурации почтового ящика.

Вызов `unstashAll()` помещает сообщения из приставки в почтовый ящик актора до тех пор, пока не будет достигнута емкость
 почтового ящика (если таковая имеется, обратите внимание, что сообщения из stash добавляются в почтовый ящик). 
 В случае переполнения ограниченного почтового ящика возникает сообщение `MessageQueueAppendFailedException`. После вызова
  метода `unstashAll()` гарантируется, что stash будет пустым.

`Stash` поддерживается `scala.collection.immutable.Vector`. В результате даже очень большое количество сообщений может
 быть спрятано без существенного влияния на производительность.
 
>Обратите внимание, что типаж `Stash` должен быть подмешан в (подкласс) типаж Actor перед любым типажом/классом, 
который отменяет обратный вызов `preRestart`. Это означает, что нельзя писать `Actor with MyActor with Stash`, если 
`MyActor` переопределяет `preRestart`.

Обратите внимание, что тайник является частью состояния эфемерного актора, в отличие от почтового ящика. Следовательно,
 его нужно управлять, как и другие части состояния актора, которые имеют одно и то же свойство. Реализация `preRestart`
  типкажа `Stash` вызовет `unstashAll()`, что обычно является желаемым поведением.

>Если вы хотите, чтобы ваш актор мог работать только с неограниченным типом, вместо этого вы должны использовать 
свойство `UnboundedStash`.

### Акторы и исключения
Может случиться так, что, когда сообщение обрабатывается актором, создается какое-то исключение.

#### Что происходит с сообщением
Если исключение генерируется при обработке сообщения (т.е. выведенного из его почтового ящика и переданного текущему 
поведению), это **сообщение будет потеряно**. Важно понимать, что он не помещается на почтовый ящик. Поэтому, если вы 
хотите повторить обработку сообщения, **вам нужно разобраться с ним сами, поймав исключение и повторите попытку**. 
Убедитесь, что вы добавили привязку к числу повторных попыток, так как вы не хотите, чтобы система зависала (так 
потребляя много циклов процессора, не добиваясь прогресса).

#### Что происходит с почтовым ящиком
Если при обработке сообщения генерируется исключение, с почтовым ящиком ничего не происходит. Если актор перезагружен,
 там будет тот же самый почтовый ящик. Таким образом, все сообщения на этом почтовом ящике будут там.

#### Что происходит с актором
Если код внутри актора выдает исключение, этот актор приостанавливается и процесс надзора запускается.
 В зависимости от решения супервизора актор возобновляется (как будто ничего не происходит), перезапускается (уничтожает
  его внутреннее состояние и начинает с нуля) или прекращается.
  

### Расширение участников с использованием цепочки PartialFunction
Иногда бывает полезно делиться общим поведением нескольких акторов или составлять поведение одного актора из 
нескольких меньших функций. Это возможно, потому что метод приема актора возвращает `Actor.Receive`, который является
 псевдонимом типа `PartialFunction[Any, Unit]`, и частичные функции могут быть соединены вместе с помощью метода 
 `PartialFunction#orElse`. Вы можете объединить столько функций, сколько вам нужно, однако вы должны иметь в виду, 
 что выигрывает «первое совпадение», что может быть важно при объединении функций, которые могут обрабатывать однотипные
  сообщения.

Например, представьте, что у вас есть набор акторов, которые являются либо `Producers` или `Consumers`, но иногда
 имеет смысл иметь актора, разделяющего оба поведения. Это может быть достигнуто без необходимости дублирования 
 кода путем извлечения поведения к чертам и реализации `receive` актора в качестве комбинации этих частичных функций.

```scala
trait ProducerBehavior {
  this: Actor ⇒

  val producerBehavior: Receive = {
    case GiveMeThings ⇒
      sender() ! Give("thing")
  }
}

trait ConsumerBehavior {
  this: Actor with ActorLogging ⇒

  val consumerBehavior: Receive = {
    case ref: ActorRef ⇒
      ref ! GiveMeThings

    case Give(thing) ⇒
      log.info("Got a thing! It's {}", thing)
  }
}

class Producer extends Actor with ProducerBehavior {
  def receive = producerBehavior
}

class Consumer extends Actor with ActorLogging with ConsumerBehavior {
  def receive = consumerBehavior
}

class ProducerConsumer extends Actor with ActorLogging
  with ProducerBehavior with ConsumerBehavior {

  def receive = producerBehavior.orElse[Any, Unit](consumerBehavior)
}

// protocol
case object GiveMeThings
final case class Give(thing: Any)
```

Вместо наследования одна и та же картина может быть применена посредством композиции - составьте метод приема, 
используя частичные функции от делегатов.


### Шаблоны инициализации
Богатые жизненные хуки акторов предоставляют полезный инструментарий для реализации различных шаблонов инициализации. 
В течение жизни `ActorRef` актор может потенциально пройти несколько перезапусков, где старый экземпляр заменяется новым, 
невидимым для внешнего наблюдателя, который видит только `ActorRef`.

Инициализация может потребоваться каждый раз, когда актор создается, но иногда требуется инициализация только при 
рождении первого экземпляра, когда создается `ActorRef`. В следующих разделах представлены шаблоны для различных 
потребностей инициализации.

#### Инициализация через конструктор
Использование конструктора для инициализации имеет различные преимущества. Прежде всего, он позволяет использовать 
поля val для хранения любого состояния, которое не изменяется в течение жизни экземпляра актора, делая реализацию 
актора более надежной. Конструктор вызывается, когда создается экземпляр актора, вызывающий actorOf, а также при 
перезапуске, поэтому внутренности актора всегда могут предполагать, что произошла правильная инициализация. Это также
 является недостатком такого подхода, так как есть случаи, когда вы хотите избежать повторной инициализации внутренних
  компонентов при перезапуске. Например, часто бывает полезно сохранить дочерних акторов через перезагрузки. В следующем
   разделе дается шаблон для этого случая.

#### Инициализация через preStart
Метод `preStart()` актора вызывается только один раз непосредственно во время инициализации первого экземпляра, то есть
 при создании его `ActorRef`. В случае перезапуска `preStart()` вызывается из `postRestart()`, поэтому, если не 
 переопределяется, при каждом перезапуске вызывается `preStart()`. Однако, переопределяя `postRestart()`, можно отключить
  это поведение и убедиться, что есть только один вызов `preStart()`.

Одним из полезных способов использования этого шаблона является отключить создание новых `ActorRefs` для детей во время
 перезапуска. Это может быть достигнуто путем переопределения `preRestart()`. Ниже приведена реализация этих хуков 
 жизненного цикла по умолчанию:

```scala
override def preStart(): Unit = {
  // Инициализировать детей здесь
}

// Переопределение postRestart для отключения вызова preStart ()
// после перезапуска
override def postRestart(reason: Throwable): Unit = ()

// Реализация preRestart() по умолчанию останавливает всех детей актора. 
// Чтобы отказаться от остановки детей, нужно переопределить preRestart()
override def preRestart(reason: Throwable, message: Option[Any]): Unit = {
  // Сохраняем вызов postStop(), но не останавливаем детей
  postStop()
}
```

Обратите внимание, что дочерние участники все еще перезапускаются, но новый `ActorRef` не создается. Можно рекурсивно 
применять те же принципы для детей, гарантируя, что их метод `preStart()` вызывается только при создании их ссылок.


#### Инициализация посредством передачи сообщений
Бывают случаи, когда невозможно передать всю информацию, необходимую для инициализации актора в конструкторе, например,
 при наличии круговых зависимостей. В этом случае актор должен прослушать сообщение инициализации, и использовать 
  `become()` или конечный переход состояния состояния машины для кодирования инициализированных и неинициализированных
   состояний актора.

```scala
var initializeMe: Option[String] = None

override def receive = {
  case "init" ⇒
    initializeMe = Some("Up and running")
    context.become(initialized, discardOld = true)
}

def initialized: Receive = {
  case "U OK?" ⇒ initializeMe foreach { sender() ! _ }
}
```

Если актер может получать сообщения до того, как он был инициализирован, полезным инструментом может быть `Stash`
для сохранения сообщений до завершения инициализации и повторного воспроизведения после того, как актер стал инициализирован.

>Этот шаблон следует использовать с осторожностью и применять только тогда, когда ни один из вышеприведенных шаблонов не
 применим. Одна из потенциальных проблем заключается в том, что сообщения могут быть потеряны при отправке удаленным
  исполнителям. Кроме того, публикация ActorRef в неинициализированном состоянии может привести к тому, что он получит
   сообщение пользователя до того, как будет выполнена инициализация.

[=> далее: Отказоустойчивость](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/readmes/fault-tolerance.md)

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/akka/blob/akka_starter/readme.md)