## Акторы

### Вступление
Модель Actor обеспечивает более высокий уровень абстракции для написания параллельных и распределенных систем. Это 
позволяет разработчику отказаться от явной блокировки и управления потоками, что упрощает создание правильных 
параллельных и параллельных систем. Акторы были определены в газете Карла Хьюитта в 1973 году, но были популяризированы 
языком Erlang и использовались, например, в Эрикссон с большим успехом для создания высококонкурентных и надежных 
телекоммуникационных систем.

### Создание акторов

#### Определение класса Actor
Акторы реализуются путем расширения базового типажа Актора и реализации метода `receive`. Метод **`receive`** должен определять 
ряд операторов `case` (который имеет тип `PartialFunction[Any, Unit]`), который определяет, какие сообщения может 
обрабатывать ваш актор, используя стандартное сопоставление шаблонов Scala, а также реализацию того, как сообщения 
должны обрабатываться.

Вот пример:

```scala
import akka.actor.Actor
import akka.actor.Props
import akka.event.Logging

class MyActor extends Actor {
  val log = Logging(context.system, this)

  def receive = {
    case "test" ⇒ log.info("получен тест")
    case _      ⇒ log.info("получено неизвестное сообщение")
  }
}
```

Обратите внимание, что `receive` цикл сообщений является исчерпывающим. Это означает, что вам необходимо предоставить 
соответствие шаблону всем сообщениям, которые оно может принять, и если вы хотите иметь возможность обрабатывать 
неизвестные сообщения, тогда вам нужно иметь случай по умолчанию, как в приведенном выше примере. В противном случае 
`akka.actor.UnhandledMessage` (`message`, `sender`, `recipient`) будет опубликован в `ActorSystem`s `EventStream`.

Обратите внимание, что возвращаемый тип поведения, определенный выше, - `Unit`; если актор должен ответить на полученное сообщение, это должно быть сделано явно, как описано ниже.

Результатом метода `receive` является объект частичной функции, который хранится внутри актора в качестве его 
«первоначального поведения».

```scala
import akka.actor.{ ActorSystem, Actor, ActorRef, Props, PoisonPill }
import language.postfixOps
import scala.concurrent.duration._

case object Ping
case object Pong

class Pinger extends Actor {
  var countDown = 100

  def receive = {
    case Pong ⇒
      println(s"${self.path} received pong, count down $countDown")

      if (countDown > 0) {
        countDown -= 1
        sender() ! Ping
      } else {
        sender() ! PoisonPill
        self ! PoisonPill
      }
  }
}

class Ponger(pinger: ActorRef) extends Actor {
  def receive = {
    case Ping ⇒
      println(s"${self.path} received ping")
      pinger ! Pong
  }
}

    val system = ActorSystem("pingpong")

    val pinger = system.actorOf(Props[Pinger], "pinger")

    val ponger = system.actorOf(Props(classOf[Ponger], pinger), "ponger")

    import system.dispatcher
    system.scheduler.scheduleOnce(500 millis) {
      ponger ! Ping
    }
```

#### Реквизит (Props)
`Props` - это класс конфигурации, который указывает параметры для создания участников, рассматривая его как непреложный 
и, следовательно, свободно распространяемый рецепт создания актора, включая связанную информацию о развертывании 
(например, какой диспетчер использовать). Вот несколько примеров создания экземпляра реквизита.

```scala
import akka.actor.Props

val props1 = Props[MyActor]
val props2 = Props(new ActorWithArgs("arg")) // осторожно, см. ниже
val props3 = Props(classOf[ActorWithArgs], "arg") // нет поддержки `value class arguments`
```

Второй вариант показывает, как передать аргументы конструктора создаваемому Актору, но его следует использовать только 
вне участников, как описано ниже.

В последней строке показана возможность передавать аргументы конструктора независимо от используемого им контекста. 
Наличие конструктора соответствия проверяется во время построения объекта Props, в результате чего возникает исключение 
`IllegalArgumentException`, если найдены конструкторы с отсутствием или множественным соответствием.

>Рекомендуемый подход к созданию Props акторане поддерживается для случаев, когда конструктор-актор принимает 
классы значений в качестве аргументов.

#### Опасные варианты

```scala
//  НЕ РЕКОМЕНДУЕТСЯ в рамках другого актора: призывает закрыть закрывающий класс
val props7 = Props(new MyActor)
```

Этот метод не рекомендуется использовать в рамках другого актора, потому что он поощряет закрытие охватывающей области, 
что приводит к несериализуемым `Props` и возможно условиям гонки (нарушая инкапсуляцию актора). С другой стороны, использование
 этого варианта на фабрике Props в сопутствующем объекте актора, как описано в «Рекомендуемой практике» ниже, полностью 
 прекрасное.

Для этих методов использовалось два варианта использования: передача аргументов конструктора актору, который решается 
недавно введенным методом `Props.apply(clazz, args)` выше или рекомендуемой практикой ниже, и созданием акторов «на месте»
 как анонимных классы. Последнее должно быть решено, вместо того, чтобы вместо этого использовать эти классы с именами
  классов (если они не объявлены в объекте верхнего уровня, тогда эта ссылка на экземпляр экземпляра должна быть 
  передана в качестве первого аргумента).
  
>Предупреждение!  Объявление одного актора в другом очень опасно и разрушает инкапсуляцию актора. Никогда не 
передавайте эту ссылку актору в реквизиты!  



_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/akka/blob/akka_starter/readme.md)