## Акторы

### Вступление
Модель Actor обеспечивает более высокий уровень абстракции для написания параллельных и распределенных систем. Это 
позволяет разработчику отказаться от явной блокировки и управления потоками, что упрощает создание правильных 
параллельных и параллельных систем. Акторы были определены в газете Карла Хьюитта в 1973 году, но были популяризированы 
языком Erlang и использовались, например, в Эрикссон с большим успехом для создания высококонкурентных и надежных 
телекоммуникационных систем.

### Создание акторов

#### Определение класса Actor
Акторы реализуются путем расширения базового типажа Актора и реализации метода `receive`. Метод **`receive`** должен определять 
ряд операторов `case` (который имеет тип `PartialFunction[Any, Unit]`), который определяет, какие сообщения может 
обрабатывать ваш актор, используя стандартное сопоставление шаблонов Scala, а также реализацию того, как сообщения 
должны обрабатываться.

Вот пример:

```scala
import akka.actor.Actor
import akka.actor.Props
import akka.event.Logging

class MyActor extends Actor {
  val log = Logging(context.system, this)

  def receive = {
    case "test" ⇒ log.info("получен тест")
    case _      ⇒ log.info("получено неизвестное сообщение")
  }
}
```

Обратите внимание, что `receive` цикл сообщений является исчерпывающим. Это означает, что вам необходимо предоставить 
соответствие шаблону всем сообщениям, которые оно может принять, и если вы хотите иметь возможность обрабатывать 
неизвестные сообщения, тогда вам нужно иметь случай по умолчанию, как в приведенном выше примере. В противном случае 
`akka.actor.UnhandledMessage` (`message`, `sender`, `recipient`) будет опубликован в `ActorSystem`s `EventStream`.

Обратите внимание, что возвращаемый тип поведения, определенный выше, - `Unit`; если актор должен ответить на полученное сообщение, это должно быть сделано явно, как описано ниже.

Результатом метода `receive` является объект частичной функции, который хранится внутри актора в качестве его 
«первоначального поведения».

```scala
import akka.actor.{ ActorSystem, Actor, ActorRef, Props, PoisonPill }
import language.postfixOps
import scala.concurrent.duration._

case object Ping
case object Pong

class Pinger extends Actor {
  var countDown = 100

  def receive = {
    case Pong ⇒
      println(s"${self.path} received pong, count down $countDown")

      if (countDown > 0) {
        countDown -= 1
        sender() ! Ping
      } else {
        sender() ! PoisonPill
        self ! PoisonPill
      }
  }
}

class Ponger(pinger: ActorRef) extends Actor {
  def receive = {
    case Ping ⇒
      println(s"${self.path} received ping")
      pinger ! Pong
  }
}

    val system = ActorSystem("pingpong")

    val pinger = system.actorOf(Props[Pinger], "pinger")

    val ponger = system.actorOf(Props(classOf[Ponger], pinger), "ponger")

    import system.dispatcher
    system.scheduler.scheduleOnce(500 millis) {
      ponger ! Ping
    }
```

#### Реквизит (Props)
`Props` - это класс конфигурации, который указывает параметры для создания участников, рассматривая его как непреложный 
и, следовательно, свободно распространяемый рецепт создания актора, включая связанную информацию о развертывании 
(например, какой диспетчер использовать). Вот несколько примеров создания экземпляра реквизита.

```scala
import akka.actor.Props

val props1 = Props[MyActor]
val props2 = Props(new ActorWithArgs("arg")) // осторожно, см. ниже
val props3 = Props(classOf[ActorWithArgs], "arg") // нет поддержки `value class arguments`
```

Второй вариант показывает, как передать аргументы конструктора создаваемому Актору, но его следует использовать только 
вне участников, как описано ниже.

В последней строке показана возможность передавать аргументы конструктора независимо от используемого им контекста. 
Наличие конструктора соответствия проверяется во время построения объекта Props, в результате чего возникает исключение 
`IllegalArgumentException`, если найдены конструкторы с отсутствием или множественным соответствием.

>Рекомендуемый подход к созданию Props актора не поддерживается для случаев, когда конструктор-актор принимает 
классы значений в качестве аргументов.

#### Опасные варианты

```scala
//  НЕ РЕКОМЕНДУЕТСЯ в рамках другого актора: призывает закрыть закрывающий класс
val props7 = Props(new MyActor)
```

Этот метод не рекомендуется использовать в рамках другого актора, потому что он поощряет закрытие охватывающей области, 
что приводит к несериализуемым `Props` и возможно условиям гонки (нарушая инкапсуляцию актора). С другой стороны, использование
 этого варианта на фабрике Props в сопутствующем объекте актора, как описано в «Рекомендуемой практике» ниже, полностью 
 прекрасное.

Для этих методов использовалось два варианта использования: передача аргументов конструктора актору, который решается 
недавно введенным методом `Props.apply(clazz, args)` выше или рекомендуемой практикой ниже, и созданием акторов «на месте»
 как анонимных классы. Последнее должно быть решено, вместо того, чтобы вместо этого использовать эти классы с именами
  классов (если они не объявлены в объекте верхнего уровня, тогда эта ссылка на экземпляр экземпляра должна быть 
  передана в качестве первого аргумента).
  
>Предупреждение!  Объявление одного актора в другом очень опасно и разрушает инкапсуляцию актора. Никогда не 
передавайте эту ссылку актору в реквизиты!  

#### Крайние случаи (Edge cases)
В создании актора есть два крайних случая:

* Актор с аргументами `AnyVal`.

```scala
case class MyValueClass(v: Int) extends AnyVal
```

```scala
class ValueActor(value: MyValueClass) extends Actor {
  def receive = {
    case multiplier: Long ⇒ sender() ! (value.v * multiplier)
  }
}
val valueClassProp = Props(classOf[ValueActor], MyValueClass(5)) // Unsupported
```

* Актор со значениями конструктора по умолчанию.

```scala
class DefaultValueActor(a: Int, b: Int = 5) extends Actor {
  def receive = {
    case x: Int ⇒ sender() ! ((a + x) * b)
  }
}

val defaultValueProp1 = Props(classOf[DefaultValueActor], 2.0) // Unsupported

class DefaultValueActor2(b: Int = 5) extends Actor {
  def receive = {
    case x: Int ⇒ sender() ! (x * b)
  }
}
val defaultValueProp2 = Props[DefaultValueActor2] // Unsupported
val defaultValueProp3 = Props(classOf[DefaultValueActor2]) // Unsupported
```

В обоих случаях исключение `IllegalArgumentException` будет брошено, из-за того что никакой конструктор соответствия не найден.

В следующем разделе объясняются рекомендуемые способы создания реквизита Актора таким образом, который одновременно 
защищает от этих крайних случаев.

#### Рекомендуемая практика
Это хорошая идея, чтобы предоставить фабричные методы на сопутствующем объекте каждого Актора, которые помогают 
поддерживать создание подходящих реквизитов как можно ближе к определению актора. Это также позволяет избежать ошибок, 
связанных с использованием метода `Props.apply(...)`, который принимает аргумент `by-name`, поскольку внутри 
объекта-компаньона данный блок кода не сохранит ссылку на свою охватывающую область:

```scala
object DemoActor {
  /**
    * Создайте реквизит для актора этого типа.
    *
    * @param magicNumber - Магическое число, которое нужно передать конструктору этого актора.
    * @ возвратите реквизит для создания этого актора, который затем может быть дополнительно настроен
    * (например, вызов `.withDispatcher ()` на нем)
   */
  def props(magicNumber: Int): Props = Props(new DemoActor(magicNumber))
}

class DemoActor(magicNumber: Int) extends Actor {
  def receive = {
    case x: Int ⇒ sender() ! (x + magicNumber)
  }
}

class SomeOtherActor extends Actor {
  // Props(new DemoActor(42)) не будет безопасным
  context.actorOf(DemoActor.props(42), "demo")
  // ...
}
```

Другая хорошая практика заключается в том, чтобы объявить, какие сообщения может получить Актор в сопутствующем 
объекте Актора, что облегчает понимание того, что он может получить:

```scala
object MyActor {
  case class Greeting(from: String)
  case object Goodbye
}
class MyActor extends Actor with ActorLogging {
  import MyActor._
  def receive = {
    case Greeting(greeter) ⇒ log.info(s"I was greeted by $greeter.")
    case Goodbye           ⇒ log.info("Someone said goodbye to me.")
  }
}
```

#### Создание акторов с реквизитом
Акторы создаются путем передачи экземпляра Props в заводский метод `actorOf`, который доступен в `ActorSystem` и `ActorContext`.

```scala
import akka.actor.ActorSystem

// ActorSystem - это тяжелый объект: создавайте только одно на все приложение
val system = ActorSystem("mySystem")
val myActor = system.actorOf(Props[MyActor], "myactor2")
```

Использование `ActorSystem` создаст игроков верхнего уровня, контролируемых действующим акторским актором, в то время как 
использование контекста актора создаст дочернего актора.

```scala
class FirstActor extends Actor {
  val child = context.actorOf(Props[MyActor], name = "myChild")
  def receive = {
    case x ⇒ sender() ! x
  }
}
```

Рекомендуется создавать иерархию детей, внуков и т.д., чтобы она соответствовала логической структуре обработки отказа 
приложения.

Вызов `actorOf` возвращает экземпляр `ActorRef`. Это дескриптор экземпляра актора и единственный способ взаимодействия 
с ним. `ActorRef` неизменен (` immutable`) и имеет отношения «один к одному» с представленным им Актором. `ActorRef`
 также сериализуется и поддерживается сетью. Это означает, что вы можете сериализовать его, отправить его по проводу и 
 использовать его на удаленном хосте, и он все равно будет представлять одного и того же Актора на исходном узле по всей сети.

Параметр имени является необязательным, но вы должны предпочтительно назвать своих участников, поскольку это используется
 в сообщениях журнала и для идентификации участников. Имя не должно быть пустым или начинаться с $, но оно может содержать
  URL-кодированные символы (например, `%20` для пробела). Если данное имя уже используется другим дочерним элементом 
  для одного и того же родителя, генерируется `InvalidActorNameException`.

Акторы автоматически запускаются асинхронно при создании.

#### Классы значений как аргументы конструктора
Рекомендуемый способ создания экземпляров акторских реквизитов использует отражение во время выполнения, чтобы определить
 правильный вызывающий конструктор, и из-за технических ограничений не поддерживается, когда указанный конструктор 
 принимает аргументы, которые являются классами значений. В этих случаях вы должны либо распаковать аргументы, либо 
 создать реквизит, вызвав конструктор вручную:

```scala
class Argument(val value: String) extends AnyVal
class ValueClassActor(arg: Argument) extends Actor {
  def receive = { case _ ⇒ () }
}

object ValueClassActor {
  def props1(arg: Argument) = Props(classOf[ValueClassActor], arg) // fails at runtime
  def props2(arg: Argument) = Props(classOf[ValueClassActor], arg.value) // ok
  def props3(arg: Argument) = Props(new ValueClassActor(arg)) // ok
}
```

#### Внедрение зависимости (Dependency Injection)
Если у вашего актора есть конструктор, который принимает параметры, то они также должны быть частью реквизита (Props), как 
описано выше. Но бывают случаи, когда должен использоваться заводский метод, например, когда фактические аргументы 
конструктора определяются каркасом внедрения зависимостей.

```scala
import akka.actor.IndirectActorProducer

class DependencyInjector(applicationContext: AnyRef, beanName: String)
  extends IndirectActorProducer {

  override def actorClass = classOf[Actor]
  override def produce =
    new Echo(beanName)

  def this(beanName: String) = this("", beanName)
}

val actorRef = system.actorOf(
  Props(classOf[DependencyInjector], applicationContext, "hello"),
  "helloBean")
```

>Предупреждение! Иногда у вас может возникнуть соблазн предложить `IndirectActorProducer`, который всегда возвращает тот
 же экземпляр, например. используя `lazy val`. Это не поддерживается, поскольку это противоречит смыслу рестарта 
 актора. При использовании инверсии зависимостей, акторские бины НЕ ДОЛЖНЫ иметь синглтон скоуп.


#### Inbox
При написании кода вне участников, который должен общаться с участниками, шаблон запроса (`ask` паттерн) может быть решением 
(см. ниже), но есть две вещи, которые он не может сделать: получение нескольких ответов (например, подписка на `ActorRef`
 на службу уведомлений) и просмотр других жизненный цикл акторов. Для этих целей есть класс `Inbox`:
 
 ```scala
implicit val i = inbox()
echo ! "hello"
i.receive() should ===("hello")
```

Существует неявное преобразование из Inbox в ссылку «Актор», что означает, что в этом примере ссылка отправителя будет 
таковой у субъекта, скрытого в Inbox. Это позволяет получить ответ на последней строке. Наблюдение за актором довольно просто:

```scala
val target = // some actor
val i = inbox()
i watch target
```

### Актор API
Характористика Актора определяет только один абстрактный метод, упомянутый выше, который реализует поведение актора.
Если текущее поведение актора не соответствует принятому сообщению, вызывается необработанное сообщение, которое по 
умолчанию публикует сообщение `akka.actor.UnhandledMessage(message, sender, recipient)` в потоке событий акторской 
системы (задан элемент конфигурации `akka.actor.debug.unhandled` чтобы они были преобразованы в фактические сообщения отладки).

Кроме того, он предлагает:

* `self` ссылка на ActorRef актора
* `sender` ссылки отправителя Актор последнего полученного сообщения
* `supervisorStrategy` пользовательское переопределяемое определение - стратегия, используемая для наблюдения за 
дочерними субъектами

Эта стратегия обычно объявляется внутри актора, чтобы иметь доступ к внутреннему состоянию актора в функции решателя: 
поскольку отказ сообщается как сообщение, отправленное супервизору и обрабатывается как другие сообщения (хотя и вне 
нормального поведения), все значения и доступны переменные внутри актора, а также ссылка отправителя (которая будет 
являться непосредственным ребенком, сообщающим об ошибке, если исходный сбой произошел в отдаленном потомке, он 
по-прежнему регистрируется на одном уровне за раз).

* `context` предоставляет контекстуальную информацию для актора и текущего сообщения, например:
   * фабричные методы создания дочерних акторов (`actorOf`)
   * система, в которой актор принадлежит
   * родительский руководитель
   * контролируемые дети
   * мониторинг жизненного цикла
   * стека поведения `hotswap`

Вы можете импортировать элементы в контексте, чтобы избежать префикса доступа с помощью контекста.

```scala
class FirstActor extends Actor {
  import context._
  val myActor = actorOf(Props[MyActor], name = "myactor")
  def receive = {
    case x ⇒ myActor ! x
  }
}
```

Оставшиеся видимые методы представляют собой перехватываемые пользователем крючки жизненного цикла, которые описаны ниже:

```scala
def preStart(): Unit = ()

def postStop(): Unit = ()

def preRestart(reason: Throwable, message: Option[Any]): Unit = {
  context.children foreach { child ⇒
    context.unwatch(child)
    context.stop(child)
  }
  postStop()
}

def postRestart(reason: Throwable): Unit = {
  preStart()
}
```
Представления, показанные выше, являются значениями по умолчанию, предоставляемыми признаком Actor.

### Жизненный цикл актора

![alt text](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/images/actor/actor_lifecycle.png "actor_lifecycle")

Путь в акторской системе представляет собой «место», которое может занимать живой актор. Первоначально (кроме системных 
инициализированных участников) путь пуст. Когда вызывается `actorOf()`, он присваивает воплощение актора, описанного 
переданными `Props`, данному пути. Воплощение актора идентифицируется по пути и UID.

Стоит отметить разницу между:

* запустить снова
* остановить, а затем воссоздать актора

Повторный запуск заменяет экземпляр Actor, определенный в Props, но воплощение, и поэтому UID остается неизменным. 
Пока воплощение будет таким же, вы можете продолжать использовать тот же `ActorRef`. Перезапуск управляется `Стратегией 
надзора` родительского актора.

Жизненный цикл воплощения заканчивается, когда актор остановлен. В этот момент вызываются соответствующие события 
жизненного цикла, и наблюдающие участники уведомляются о завершении. После того, как воплощение будет остановлено, 
путь можно снова использовать повторно, создав актора с `actorOf()`. В этом случае имя нового воплощения будет таким же, 
как и предыдущее, но UID будут отличаться. Актор может быть остановлен самим актором, другим актором или `ActorSystem`.

>Важно отметить, что Акторы не останавливаются автоматически, когда больше не ссылаются, каждый созданный Актор также 
должен быть явно уничтожен. Единственное упрощение состоит в том, что остановка родительского Актора также рекурсивно 
останавливает всех дочерних Акторов, созданных этим родителем.

`ActorRef` всегда представляет собой воплощение (путь и UID), а не только определенный путь. Поэтому, если актор 
остановлен и создается новый с тем же именем, ActorRef из старого воплощения не будет указывать на новый.

`ActorSelection`, с другой стороны, указывает на путь (или несколько путей, если используются подстановочные знаки), и 
совершенно не обращает внимания на то, что в настоящее время оно занимает его воплощение. По этой причине нельзя наблюдать
 за `ActorSelection`. Можно разрешить `ActorRef` текущего воплощения, живущего под путём, отправив сообщение `Identify` на 
 `ActorSelection`, на который будет отправлен ответ `ActorIdentity`, содержащий правильную ссылку. 
 Это также можно сделать с помощью метода resolveOne для `ActorSelection`, который возвращает будущее соответствующего `ActorRef`.

#### Мониторинг жизненного цикла (DeathWatch)
Чтобы быть уведомленным о прекращении действия другого актора (т.е. навсегда, а не на временном сбое и перезапуске), 
актор может зарегистрироваться для получения завершенного сообщения, отправленного другим актором после прекращения 
действия. Эта услуга предоставляется компонентом `DeathWatch` системы акторов.

Регистрация монитора проста:
```scala
import akka.actor.{ Actor, Props, Terminated }

class WatchActor extends Actor {
  val child = context.actorOf(Props.empty, "child")
  context.watch(child) // <-- this is the only call needed for registration
  var lastSender = context.system.deadLetters

  def receive = {
    case "kill" ⇒
      context.stop(child); lastSender = sender()
    case Terminated(`child`) ⇒ lastSender ! "finished"
  }
}
```

Следует отметить, что завершенное (`Terminated`) сообщение генерируется независимо от порядка, в котором происходит 
регистрация и завершение. В частности, наблюдающий актор получит сообщение с прекращением действия, даже если наблюдаемый
 актор уже был прекращен во время регистрации.

Регистрация нескольких раз не обязательно приводит к генерации нескольких сообщений, но нет гарантии, что получено 
только одно такое сообщение: если завершение наблюдаемого актора сгенерировало и поставило в очередь сообщение, а 
другая регистрация будет выполнена до того, как это сообщение будет обрабатывается, то второе сообщение будет поставлено
 в очередь, так как регистрация для мониторинга уже прекращенного участника приводит к немедленному генерации завершенного
  сообщения.

Также можно отменить регистрацию, чтобы наблюдать за живостью другого актора, используя `context.unwatch(target)`. Это 
работает даже в том случае, если завершенное сообщение уже помещено в очередь в почтовом ящике; после вызова `unwatch`
 никакого завершенного сообщения для этого актора не будет обработано больше.

#### Хук старта (Start Hook)
Сразу после запуска актора вызывается его метод `preStart`.
```scala
override def preStart(): Unit = {
  child = context.actorOf(Props[MyActor], "child")
}
```

Этот метод вызывается, когда актор сначала создается. Во время перезапуска он вызывается реализацией по умолчанию
 `postRestart` по умолчанию, что означает, что, переопределяя этот метод, вы можете выбрать, будет ли код инициализации
  в этом методе вызываться только ровно один раз для этого актора или для каждого перезапуска. Код инициализации, 
  который является частью конструктора актора, всегда вызывается, когда создается экземпляр класса актора, который 
  происходит при каждом перезапуске.

#### Хуки перезапуска (Restart Hooks)
Все участники контролируются, т.е. связаны с другим игроком с стратегией обработки ошибок. Акторы могут быть перезапущены
 в случае возникновения исключения при обработке сообщения. Этот перезапуск включает в себя перечисленные выше крючки:

1. Старому актору сообщается, вызывая `preRestart` с исключением, вызвавшим перезапуск, и сообщение, вызвавшее это 
исключение; последний может быть `None`, если перезапуск не был вызван обработкой сообщения, например. когда супервизор 
не улавливает исключение и перезапускается в свою очередь своим супервизором или если актор перезапускается из-за сбоя 
брата или сестры. Если сообщение доступно, то отправитель этого сообщения также доступен обычным способом (т.е. путем 
вызова `sender`). Этот метод является лучшим местом для очистки, подготовки передачи к экземпляру нового актора и т.д.
 по умолчанию он останавливает всех детей и вызывает `postStop`. 
2. Первоначальная фабрика из вызова `actorOf` используется для создания нового экземпляра. 
3. Метод postRestart нового участника вызывается с исключением, вызвавшим перезапуск. По умолчанию вызывается `preStart`, 
как и в обычном случае запуска.

Актор перезапускает замену только фактического объекта актора; при повторном запуске содержимое почтового ящика не будет
 затронуто, поэтому обработка сообщений возобновится после возврата к клику postRestart. Сообщение, вызвавшее исключение,
  не будет получено повторно. Любое сообщение, отправленное актору во время его перезапуска, будет помещено в очередь 
  на его почтовый ящик, как обычно.

>Имейте в виду, что упорядочение уведомлений об отказах относительно сообщений пользователя не является детерминированным.
 В частности, родитель может перезагрузить свой дочерний элемент до того, как он обработает последние сообщения, 
 отправленные дочерним элементом до сбоя.
 
#### Хук остановки (Stop Hook)
После остановки актора вызывается его хук `postStop`, который может быть использован, например. за отмену регистрации
 этого участника из других служб. Этот хук гарантированно будет запущен после того, как очередь сообщений будет 
 отключена для этого актора, то есть сообщения, отправленные остановленному игроку, будут перенаправлены на 
 `deadLetters` системы `ActorSystem`.
 
### Идентификация акторов с помощью выбора актора
Как описано в `Actor References`, `Paths and Addresses`, **каждый актор имеет уникальный логический путь**, который 
получается, следуя цепочке участников от дочернего к родительскому до достижения корня системы акторов и **имеет 
физический путь**, который может отличаться если в цепочку контроля входят любые удаленные супервизоры. Эти пути 
используются системой для поиска акторов. Например, когда получено удаленное сообщение и выполняется поиск получателя, 
но они также полезны более непосредственно: участники могут искать других участников, указывая абсолютные или 
относительные пути - логические или физические - и получать обратно `ActorSelection` с результатом:

```scala
// будет искать этот абсолютный путь
context.actorSelection("/user/serviceA/aggregator")
// будет искать родного брата под тем же супервизором
context.actorSelection("../joe")
```

>Всегда лучше общаться с другими Акторами, используя их ActorRef вместо того, чтобы полагаться на ActorSelection. 

Исключения:
1. отправка сообщений с использованием средства доставки «По крайней мере один раз»
2. инициирование первого контакта с удаленной системой. 

Во всех других случаях `ActorRefs` могут быть предоставлены во время создания или инициализации Актора, передачи их от 
родителя к ребенку или введения Акторов, отправив свои ActorRefs другим Акторам в сообщениях.

Поставляемый путь анализируется как `java.net.URI`, что означает, что он разделен на **`/`** на элементы пути. Если 
путь начинается с `/`, он является абсолютным, и поиск начинается с корневого опекуна (который является родительским 
элементом `/user`); иначе он начинается с текущего участника. Если элемент пути равен **`..`**, поиск будет идти 
«вверх» к супервизору текущего перемещаемого актора, иначе он будет «вниз» к названному ребенку. Следует отметить, что
 здесь на дорожках актора всегда подразумевается логическая структура, то есть супервизор.

Элементы пути выбора актора могут содержать шаблоны подстановочных знаков, позволяющие передавать сообщения в этот раздел:

```scala
// будем искать все[ детям serviceB с именами, начинающимися с `worker`
context.actorSelection("/user/serviceB/worker*")
// будет искать всех братьев и сестер под тем же супервизором
context.actorSelection("../*")
```

Сообщения могут быть отправлены с помощью `ActorSelection`, и при передаче каждого сообщения просматривается путь 
`ActorSelection`. Если выбор не соответствует ни одному актору, сообщение будет удалено.

Чтобы приобрести `ActorRef` для выбора `ActorSelection`, вам нужно отправить сообщение на выбор и использовать ссылку
 отправителя `sender()` ответа от актора. Существует встроенное сообщение `Identify`, которое все Акторы поймут и 
 автоматически ответят сообщением `ActorIdentity`, содержащим `ActorRef`. Это сообщение обрабатывается специально 
 субъектами, которые пересекаются в том смысле, что если конкретный поиск имени терпит неудачу (т.е. элемент пути без 
 подстановочных знаков не соответствует активному актору), то генерируется отрицательный результат. Обратите внимание, 
 что это не означает, что доставка этого ответа гарантирована, это все равно нормальное сообщение.

```scala
import akka.actor.{ Actor, Props, Identify, ActorIdentity, Terminated }

class Follower extends Actor {
  val identifyId = 1
  context.actorSelection("/user/another") ! Identify(identifyId)

  def receive = {
    case ActorIdentity(`identifyId`, Some(ref)) ⇒
      context.watch(ref)
      context.become(active(ref))
    case ActorIdentity(`identifyId`, None) ⇒ context.stop(self)

  }

  def active(another: ActorRef): Actor.Receive = {
    case Terminated(`another`) ⇒ context.stop(self)
  }
}
```

Вы также можете приобрести `ActorRef` для выбора `ActorSelection` с помощью метода `resolveOne` для выбора `ActorSelection`. 
Он возвращает будущее соответствующего `ActorRef`, если такой актор существует. Он завершается сбоем 
`akka.actor.ActorNotFound`, если такого участника нет или идентификация не завершена в течение установленного таймаута.

Адреса удаленных акторов также могут быть просмотрены, если удаленный доступ включен:

```scala
context.actorSelection("akka.tcp://app@otherhost:1234/user/serviceB")
```

### Сообщения и неизменяемость (Messages and immutability)

>Сообщения могут быть любыми объектами, но должны быть неизменными. Scala не может обеспечить неизменность (пока), так 
что это должно быть по соглашению. Примитивы типа String, Int, Boolean всегда неизменны. Помимо этого рекомендуется 
использовать классы Case Scala, которые являются неизменными (если вы явно не раскрываете состояние) и отлично 
справляются с сопоставлением шаблонов со стороны приемника.

Вот пример:

```scala
case class User(name: String)
case class Register(user: User)

val user    = User("Mike")
val message = Register(user)
```

### Отправка сообщений
Сообщения отправляются актору одним из следующих способов:

* **`!`** означает «огонь и забыть», например. отправить сообщение асинхронно и немедленно вернуться. 
Также известен как **`tell`**.
* **`?`** отправляет сообщение асинхронно и возвращает `Future`, представляющее возможный ответ. Также известен как **`ask`**.
Порядок сообщений гарантируется для каждого отправителя.

>Есть последствия для производительности использования `ask`, потому что что-то нужно отслеживать, когда оно истекает, 
должно быть что-то, что превращает `Promise` в `ActorRef`, и оно также должно быть доступно через удаленный доступ. 
Поэтому всегда предпочитайте `tell` для лучшей производительности, а `ask` если нет другой возможности.

#### Tell: Fire-forget
Это предпочтительный способ отправки сообщений. Нет блокировки, ожидающей сообщения. Это дает наилучшие характористики 
параллелизма и масштабируемости.

```scala
actorRef ! message
```

Если он вызван изнутри Актора, ссылка на отправку актора будет неявно передаваться вместе с сообщением и доступна 
получающему Актору в его методе `sender(): ActorRef`. Целевой актор может использовать это, чтобы ответить первоначальному
 отправителю, используя `sender() ! replyMsg`.

Если он вызван из экземпляра, который не является Актором, отправитель по умолчанию будет `deadLetters` ссылкой актора.

#### Ask: Send-And-Receive-Future
В шаблоне запроса участвуют как акторы, так и фьючерсы, поэтому он предлагается как шаблон использования, а не метод на ActorRef:

```scala
import akka.pattern.{ ask, pipe }
import system.dispatcher // The ExecutionContext that will be used
final case class Result(x: Int, s: String, d: Double)
case object Request

implicit val timeout = Timeout(5 seconds)  // needed for `?` below

val f: Future[Result] =
  for {
    x ← ask(actorA, Request).mapTo[Int]    // call pattern directly
    s ← (actorB ask Request).mapTo[String] // call by implicit conversion
    d ← (actorC ? Request).mapTo[Double]   // call by symbolic name
  } yield Result(x, s, d)

f pipeTo actorD // .. or ..
pipe(f) to actorD
```

Этот пример демонстрирует `ask` вместе с шаблоном `pipeTo` на фьючерсах, потому что это, вероятно, будет общей 
комбинацией. Обратите внимание, что все вышеперечисленное полностью не блокируется и асинхронно: `ask` производит `Future`,
 три из которых состоят из нового будущего, используя `for-comprehension`, а затем `pipeTo` устанавливает обработчик 
 `onComplete` на Future, чтобы повлиять на представление агрегированный результат для другого актора.

Использование `ask` отправит сообщение получающему актору, как и с `tell`, и принимающий актор должен ответить 
`sender() ! reply`, чтобы завершить возвращенное будущее со значением. Операция запроса включает создание внутреннего 
субъекта для обработки этого ответа, который должен иметь таймаут, после которого он уничтожается, чтобы не утечка 
ресурсов; см. ниже.

>Чтобы завершить будущее с исключением, вам необходимо отправить отправителю сообщение `akka.actor.Status.Failure`. 
Это не делается автоматически, когда актор выдает исключение при обработке сообщения. 
Обратите внимание, что `scala.util.Failure` и `scala.util.Success` - это подтипы `Try`,  не обрабатываются специально и 
будут заполнять запрос `Future` с заданным значением - только сообщения `akka.actor.Status` обрабатываются специально 
шаблоном запроса.

```scala
try {
  val result = operation()
  sender() ! result
} catch {
  case e: Exception ⇒
    sender() ! akka.actor.Status.Failure(e)
    throw e
}
```
Если актор не завершит будущее, он истечет после периода ожидания, завершив его с помощью `AskTimeoutException`. 
Тайм-аут берется из одного из следующих мест в порядке приоритета:

1. явно заданный тайм-аут, как в:
```scala
import scala.concurrent.duration._
import akka.pattern.ask
val future = myActor.ask("hello")(5 seconds)
```
2. неявный аргумент (`implicit argument`) типа `akka.util.Timeout`, например .
```scala
import scala.concurrent.duration._
import akka.util.Timeout
import akka.pattern.ask
implicit val timeout = Timeout(5 seconds)
val future = myActor ? "hello"
```

Методы `onComplete`, `onSuccess` или `onFailure` будущего могут использоваться для регистрации обратного вызова для 
получения уведомления, когда будущее завершается, что дает вам возможность избежать блокировки.

>При использовании будущих обратных вызовов, таких как `onComplete`, `onSuccess` или `onFailure`, внутри акторов вам 
необходимо избегать закрытия над ссылкой содержащего актора, то есть не вызывать методы или доступ к изменяемому 
состоянию на окружающем акторе из обратного вызова. Это нарушит инкапсуляцию актора и может привести к ошибкам 
синхронизации и условиям гонки, потому что обратный вызов будет запланирован одновременно с окружающим актором. 
К сожалению, пока не удается обнаружить эти незаконные обращения во время компиляции. 

### Получение сообщений
Актор должен реализовать метод `receive` для приема сообщений:

```scala
type Receive = PartialFunction[Any, Unit]

def receive: Actor.Receive
```

Этот метод возвращает `PartialFunction`, например. предложение `match / case`, в котором сообщение может быть сопоставлено
 с различными предложениями case, используя сопоставление шаблонов Scala. Вот пример:
 
```scala
import akka.actor.Actor
import akka.actor.Props
import akka.event.Logging

class MyActor extends Actor {
  val log = Logging(context.system, this)

  def receive = {
    case "test" ⇒ log.info("received test")
    case _      ⇒ log.info("received unknown message")
  }
}
```
### Ответ на сообщения

Если вы хотите иметь дескриптор для ответа на сообщение, вы можете использовать `sender()`, который дает вам `ActorRef`. 
Вы можете ответить, отправив этому ActorRef с `sender() ! replyMsg`. Вы также можете сохранить ActorRef для ответа 
позже или передать другим участникам. Если отправителя нет (сообщение было отправлено без актора или будущего контекста),
 то отправитель по умолчанию ссылается на «мертвое письмо».
 
```scala
sender() ! x // ответы будут переданы этому актору
```

### Тайм-аут приема
`ActorContext setReceiveTimeout` определяет тайм-аут бездействия, после которого запускается отправка сообщения 
`ReceiveTimeout`. Когда указано, функция приема должна иметь возможность обрабатывать сообщение `akka.actor.ReceiveTimeout`.
 1 миллисекунда является минимальным временем ожидания.

Обратите внимание, что тайм-аут приема может срабатывать и выдавать сообщение `ReceiveTimeout` сразу после того, как 
другое сообщение было выставлено в очередь; следовательно, не гарантируется, что после приема тайм-аута приема должен 
был быть заранее установленный период времени, как он сконфигурирован с помощью этого метода.

После установки тайм-аут приема остается в силе (т.е. продолжает многократно срабатывать после периодов бездействия). 
Перейдите в `Duration.Undeined` для отключения этой функции.

```scala
import akka.actor.ReceiveTimeout
import scala.concurrent.duration._
class MyActor extends Actor {
  // To set an initial delay
  context.setReceiveTimeout(30 milliseconds)
  def receive = {
    case "Hello" ⇒
      // To set in a response to a message
      context.setReceiveTimeout(100 milliseconds)
    case ReceiveTimeout ⇒
      // To turn it off
      context.setReceiveTimeout(Duration.Undefined)
      throw new RuntimeException("Receive timed out")
  }
}
```

Сообщения, отмеченные `NotInfluenceReceiveTimeout`, не будут сбрасывать таймер. Это может быть полезно, когда 
`ReceiveTimeout` должен быть запущен из-за внешнего бездействия, но не под влиянием внутренней активности, например, 
запланированных сообщений шедулера.

### Таймеры, запланированные сообщения
Сообщения могут быть запланированы для отправки с помощью планировщика напрямую, но при 
планировании периодических или отдельных сообщений в акторе самому себе удобнее и безопаснее использовать поддержку 
именованных таймеров. Жизненный цикл запланированных сообщений может быть сложен для управления, когда актор перезагружается
 и об этом заботятся таймеры.
 
```scala
import scala.concurrent.duration._

import akka.actor.Actor
import akka.actor.Timers

object MyActor {
  private case object TickKey
  private case object FirstTick
  private case object Tick
}

class MyActor extends Actor with Timers {
  import MyActor._
  timers.startSingleTimer(TickKey, FirstTick, 500.millis)

  def receive = {
    case FirstTick ⇒
      // сделай что-нибудь полезное здесь
      timers.startPeriodicTimer(TickKey, Tick, 1.second)
    case Tick ⇒
      //сделай что-нибудь полезное здесь
  }
}
```

Каждый таймер имеет ключ и может быть заменен или отменен. Гарантируется, что **сообщение из предыдущего воплощения 
таймера с тем же ключом не получено**, даже если оно уже может быть установлено в почтовом ящике после его отмены или 
запускается новый таймер.

Таймеры привязаны к жизненному циклу актора, который владеет им, и поэтому автоматически отменяется при его перезапуске
 или остановке. Обратите внимание, что `TimerScheduler` не является потокобезопасным, т.е. он должен использоваться 
 только в пределах субъекта, владеющего им.
 
### Остановка акторов
Акторы останавливаются путем вызова метода остановки `ActorRefFactory`, то есть `ActorContext` или `ActorSystem`. Как правило,
 этот контекст используется для остановки самого актора или дочерних участников и системы для остановки игроков верхнего
  уровня. Фактическое завершение актора выполняется асинхронно, т.е. остановка может вернуться до остановки актора.
 
```scala
class MyActor extends Actor {

  val child: ActorRef = ???

  def receive = {
    case "interrupt-child" ⇒
      context stop child

    case "done" ⇒
      context stop self
  }

}
```

Обработка текущего сообщения, если оно есть, будет продолжаться до того, как актор остановится, но дополнительные 
сообщения в почтовом ящике не будут обработаны. По умолчанию эти сообщения отправляются в `deadLetters` из `ActorSystem`,
 но это зависит от реализации почтового ящика.

Прекращение действия актора происходит в два этапа: 
* сначала актор приостанавливает обработку своего почтового ящика и отправляет команду останвки всем своим дочерним 
элементам, затем он продолжает обрабатывать внутренние уведомления 
о завершении от своих дочерних элементов до тех пор, пока последний не уйдет, окончательно завершая себя (вызывая 
`postStop` , демпинг почтового ящика, публикация завершена на `DeathWatch`, сообщая своему руководителю). Эта процедура 
гарантирует, что поддеревья акторской системы закончатся упорядоченным образом, распространяя команду останвки на 
листья и собирая их подтверждение обратно остановленному супервизору. Если один из участников не отвечает (т.е. 
обрабатывает сообщение в течение длительных периодов времени и, следовательно, не принимает команду останвки), весь 
этот процесс будет зависеть.

* после `ActorSystem.terminate()`, акторы системного стража будут остановлены, и вышеупомянутый процесс обеспечит 
правильное завершение всей системы.

Хук `postStop()` вызывается после того, как актор полностью остановлен. Это позволяет очистить ресурсы:

```scala
override def postStop(): Unit =  ()

```
>Поскольку остановка актора является асинхронной, вы не можете сразу использовать имя только что остановленного 
ребенка; это приведет к исключению `InvalidActorNameException`. Вместо этого `watch()` завершающий актор и 
создавайте его замену в ответ на сообщение `Terminated`, которое в конечном итоге поступит.


_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/akka/blob/akka_starter/readme.md)