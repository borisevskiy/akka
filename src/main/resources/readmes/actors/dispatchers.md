## Диспетчеры

### Вступление
Акка `MessageDispatcher` - это то, что делает Акка акторов «тикать», это двигатель машины, так сказать. Все реализации 
`MessageDispatcher` также являются `ExecutionContext`, а это означает, что они могут использоваться для выполнения 
произвольного кода, например `Futures`.

### Диспетчер по умолчанию
Каждая система `ActorSystem` будет иметь диспетчер по умолчанию, который будет использоваться в случае, если для актора
 не настроено ничего другого. Диспетчер по умолчанию может быть настроен и по умолчанию является диспетчером с указанным
  исполнителем по умолчанию. Если создается `ActorSystem` с переданным `ExecutionContext`, этот `ExecutionContext` будет 
  использоваться как исполнитель по умолчанию для всех диспетчеров в этой `ActorSystem`. Если не указан `ExecutionContext`,
   он будет отбрасываться исполнителю, указанному в файле `akka.actor.default-dispatcher.default-executor.fallback`. 
   По умолчанию это `fork-join-executor`, который дает отличную производительность в большинстве случаев.

### Поиск диспетчера
Диспетчеры реализуют интерфейс `ExecutionContext` и поэтому могут использоваться для запуска будущих вызовов и т.д.

```scala
// for use with Futures, Scheduler, etc.
implicit val executionContext = system.dispatchers.lookup("my-dispatcher")
```

Поэтому, если вы хотите, чтобы ваш Актор был другим диспетчером, чем по умолчанию, вам нужно сделать две вещи, из 
которых первая заключается в настройке диспетчера:

```yaml
my-dispatcher {
  # Диспетчер - это имя диспетчера на основе событий
  type = Dispatcher
  # Какой вид использования ExecutionService
  executor = "fork-join-executor"
  # Конфигурация для `fork join pool`
  fork-join-executor {
    # Минимальное количество потоков для кол-ва на основе коэффициента
    parallelism-min = 2
    # Параллелизм (потоки) ... ceil (доступные процессоры * коэффициент)
    parallelism-factor = 2.0
    # Максимальное количество потоков для ограничения числа факторов на основе коэффициента
    parallelism-max = 10
  }
   # Пропускная способность определяет максимальное количество сообщений
   # обработано для каждого актора до того, как поток перейдет к следующему актору.
   # Установите на 1 для максимально возможного.
  throughput = 100
}
```

>Обратите внимание: `parallelism-max` не устанавливает верхнюю границу общего количества потоков, выделенных `ForkJoinPool`. 
Это параметр, конкретно говорящий о количестве горячих потоков, которые пул продолжает работать, чтобы уменьшить 
латентность обработки новой входящей задачи.

Другой пример, который использует «thread-pool-executor»:

```yaml
blocking-io-dispatcher {
  type = Dispatcher
  executor = "thread-pool-executor"
  thread-pool-executor {
    fixed-pool-size = 32
  }
  throughput = 1
}
```

Затем вы создаете актора как обычно и определяете диспетчера в конфигурации развертывания.

```scala
import akka.actor.Props
val myActor = context.actorOf(Props[MyActor], "myactor")
```

```yaml
akka.actor.deployment {
  /myactor {
    dispatcher = my-dispatcher
  }
}
```

Альтернативой конфигурации развертывания является определение диспетчера в коде. Если вы определяете диспетчера в 
конфигурации развертывания, тогда это значение будет использоваться вместо программно предоставленного параметра.

```scala
import akka.actor.Props
val myActor =
  context.actorOf(Props[MyActor].withDispatcher("my-dispatcher"), "myactor1")
```

Диспетчер, который вы указываете в `withDispatcher` и свойство `dispatcher` в конфигурации развертывания, фактически 
является путём в вашу конфигурацию. Таким образом, в этом примере это раздел верхнего уровня, но вы можете, например, 
поставить его в качестве подраздела, где вы должны использовать периоды для обозначения подсекций, например: 
`foo.bar.my-dispatcher`.

### Типы диспетчеров
Существует 3 разных типа диспетчеров сообщений:

#### Dispatcher

_Это диспетчер событий, который связывает набор участников с пулом потоков. Это диспетчер по умолчанию, если он не указан._

   * Доступность: неограниченно
   * Почтовые ящики: Любой, создает по одному на актора
   * Случаи использования: диспетчер по умолчанию, переборка (Default dispatcher, Bulkheading)
   * Управляемый: `java.util.concurrent.ExecutorService`. Укажите «исполнитель» (executor), используя «fork-join-executor», 
   «thread-pool-executor» или FQCN `akka.dispatcher.ExecutorServiceConfigurator`.

#### PinnedDispatcher

_Этот диспетчер выделяет уникальный поток для каждого актора, использующего его; то есть каждый актор будет иметь свой 
собственный пул потоков с одним потоком в пуле._

   * Совместимость: нет
   * Почтовые ящики: Любой, создает по одному на актора
   * Варианты использования: переборки
   * Управляемый: Любой `akka.dispatch.ThreadPoolExecutorConfigurator`. По умолчанию «thread-pool-executor».
   
#### CallingThreadDispatcher

_Этот диспетчер запускает вызовы только по текущей теме. Этот диспетчер не создает никаких новых потоков, но может 
использоваться из разных потоков одновременно для одного и того же актора._

   * Доступность: неограниченно
   * Почтовые ящики: Любой, создает по одному для каждого актора в потоке (по запросу)
   * Варианты использования: Тестирование
   * Управляемый: вызывающий поток (duh)
   
#### Дополнительные примеры конфигурации диспетчера
Настройка диспетчера с фиксированным размером пула потоков, например. для участников, выполняющих блокировку ввода-вывода:

```yaml
blocking-io-dispatcher {
  type = Dispatcher
  executor = "thread-pool-executor"
  thread-pool-executor {
    fixed-pool-size = 32
  }
  throughput = 1
}
```

И затем используя его:

```scala
val myActor = context.actorOf(Props[MyActor].withDispatcher("blocking-io-dispatcher"), "myactor2")
```

Другой пример, который использует пул потоков на основе количества ядер (например, для задач с привязкой к ЦП)

```yaml
my-thread-pool-dispatcher {
  # Диспетчер - это имя диспетчера на основе событий
  type = Dispatcher
  # Какой вид использования ExecutionService
  executor = "thread-pool-executor"
  # Конфигурация пула потоков
  thread-pool-executor {
    # минимальное количество потоков для кол-во базового номера ядра
    core-pool-size-min = 2
    # Нет основных потоков ... ceil (доступные процессоры * фактор)
    core-pool-size-factor = 2.0
    # максимальное количество потоков для кол-ва на основе коэффициента для
    core-pool-size-max = 10
  }
  # Пропускная способность определяет максимальное количество сообщений
       # обработано для каждого актера до того, как поток перейдет к следующему актеру.
       # Установите на 1 для максимально возможного.
  throughput = 100
}
```

[Подробнее](https://doc.akka.io/docs/akka/current/dispatchers.html)

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/akka/blob/akka_starter/readme.md)