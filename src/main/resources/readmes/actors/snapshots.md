## Снимки (Snapshots)

По мере того, как вы моделируете свой домен с помощью участников, вы можете заметить, что некоторые участники могут быть
 склонны накапливать чрезвычайно длинные журналы событий и испытывать длительное время восстановления. Иногда правильным
  подходом может быть разделение на несколько более короткоживущих актеров. Однако, когда это не вариант, вы можете 
  использовать моментальные снимки, чтобы значительно сократить время восстановления.

Стойкие участники могут сохранять снимки внутреннего состояния, вызывая метод `saveSnapshot`. Если сохранение моментального
 снимка завершается успешно, постоянный участник получает сообщение `SaveSnapshotSuccess`, иначе сообщение `SaveSnapshotFailure`

```scala
var state: Any = _

val snapShotInterval = 1000
override def receiveCommand: Receive = {
  case SaveSnapshotSuccess(metadata)         ⇒ // ...
  case SaveSnapshotFailure(metadata, reason) ⇒ // ...
  case cmd: String ⇒
    persist(s"evt-$cmd") { e ⇒
      updateState(e)
      if (lastSequenceNr % snapShotInterval == 0 && lastSequenceNr != 0)
        saveSnapshot(state)
    }
}
```

где метаданные имеют тип `SnapshotMetadata`:

```scala
final case class SnapshotMetadata(persistenceId: String, sequenceNr: Long, timestamp: Long = 0L)
```

Во время восстановления постоянному участнику предлагается ранее сохраненный снимок через сообщение `SnapshotOffer`, из 
которого он может инициализировать внутреннее состояние.

```scala
var state: Any = _

override def receiveRecover: Receive = {
  case SnapshotOffer(metadata, offeredSnapshot) ⇒ state = offeredSnapshot
  case RecoveryCompleted                        ⇒
  case event                                    ⇒ // ...
}
```

Повторные сообщения, которые следуют за сообщением SnapshotOffer, если они есть, моложе предлагаемого моментального 
снимка. Они, наконец, восстанавливают постоянный актер до его текущего (то есть последнего) состояния.

В общем, постоянному участнику предлагается только моментальный снимок, если этот постоянный актер ранее сохранил один 
или несколько снимков, и по крайней мере один из этих снимков соответствует `SnapshotSelectionCriteria`, который может 
быть указан для восстановления.

```scala
override def recovery = Recovery(fromSnapshot = SnapshotSelectionCriteria(
  maxSequenceNr = 457L,
  maxTimestamp = System.currentTimeMillis))
```

Если не указано, они по умолчанию устанавливают `SnapshotSelectionCriteria.Latest`, который выбирает последний 
(= самый молодой) снимок. Чтобы отключить восстановление на основе моментального снимка, приложения должны использовать 
`SnapshotSelectionCriteria.None`. Восстановление, когда ни один сохраненный моментальный снимок не соответствует 
указанному `SnapshotSelectionCriteria`, воспроизведет все журналированные сообщения.

>Чтобы использовать моментальные снимки, необходимо настроить хранилище моментальных снимков по умолчанию 
(`akka.persistence.snapshot-store.plugin`), или `PersistentActor` может явно выбрать хранилище моментальных снимков, 
переопределив `def snapshotPluginId: String`.
Поскольку для некоторых приложений приемлемо не использовать какой-либо снимок, законно не настраивать хранилище 
моментальных снимков. Тем не менее, Akka будет регистрировать предупреждающее сообщение, когда эта ситуация будет 
обнаружена, а затем продолжить работу до тех пор, пока актер не попытается сохранить моментальный снимок, после чего 
операция завершится неудачей (например, отвечая с помощью `SaveSnapshotFailure`).
Обратите внимание, что в режиме «сохранения» `Cluster Sharding` используются моментальные снимки. Если вы используете 
этот режим, вам нужно будет определить плагин хранилища снимков.

Используйте метод доставки для отправки сообщения получателю. Вызовите метод `confirmDelivery`, когда получатель ответил с 
подтверждением.

[Подробнее](https://doc.akka.io/docs/akka/current/persistence.html#snapshots)


_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/akka/blob/akka_starter/readme.md)