## Маршрутизация
### Вступление
Сообщения могут быть отправлены через маршрутизатор, чтобы эффективно направлять их к целевым участникам, 
известным как его маршруты. Маршрутизатор может использоваться как внутри, так и снаружи актора, и вы сами можете 
управлять маршрутами или использовать автономный роутер-актор с возможностями конфигурации.

В зависимости от потребностей вашего приложения могут использоваться различные стратегии маршрутизации. Akka предлагает 
несколько полезных стратегий маршрутизации прямо из коробки. Но, как вы увидите в этой главе, вы также можете создать 
свой собственный.

### Простой маршрутизатор
В следующем примере показано, как использовать маршрутизатор и управлять маршрутами внутри актора.
```scala
import akka.routing.{ ActorRefRoutee, RoundRobinRoutingLogic, Router }

class Master extends Actor {
  var router = {
    val routees = Vector.fill(5) {
      val r = context.actorOf(Props[Worker])
      context watch r
      ActorRefRoutee(r)
    }
    Router(RoundRobinRoutingLogic(), routees)
  }

  def receive = {
    case w: Work ⇒
      router.route(w, sender())
    case Terminated(a) ⇒
      router = router.removeRoutee(a)
      val r = context.actorOf(Props[Worker])
      context watch r
      router = router.addRoutee(r)
  }
}
```

Мы создаем маршрутизатор и указываем, что он должен использовать RoundRobinRoutingLogic при маршрутизации сообщений на маршруты.

Логика маршрутизации, поставляемая с Akka:

* `akka.routing.RoundRobinRoutingLogic`
* `akka.routing.RandomRoutingLogic`
* `akka.routing.SmallestMailboxRoutingLogic`
* `akka.routing.BroadcastRoutingLogic`
* `akka.routing.ScatterGatherFirstCompletedRoutingLogic`
* `akka.routing.TailChoppingRoutingLogic`
* `akka.routing.ConsistentHashingRoutingLogic`

Мы создаем маршруты как обычные дочерние акторы, завернутые в `ActorRefRoutee`. Мы следим за тем, чтобы маршруты могли 
заменять их, если они завершены.

Отправка сообщений через маршрутизатор выполняется с помощью метода маршрута, как это делается для рабочих сообщений в 
приведенном выше примере.

Маршрутизатор является неизменным и `RoutingLogic` является потокобезопасным; что означает, что они также могут 
использоваться вне участников.

>В общем, любое сообщение, отправленное на маршрутизатор, будет отправлено на его маршруты, но есть одно исключение. 
Специальные широковещательные сообщения (`Broadcast Messages `) будут отправляться на все маршруты маршрутизатора. 
Однако не используйте широковещательные сообщения, когда вы используете `BalancingPool` для маршрутов, как описано в 
специально обработанных сообщениях.

### Актор-Маршрутизатор
Маршрутизатор также может быть создан как автономный актор, который управляет самими маршрутами и загружает логику 
маршрутизации и другие настройки из конфигурации.

Этот тип роутер-актора поставляется в двух разных вариантах:

* Пул - маршрутизатор создает маршруты как дочерние субъекты и удаляет их с маршрутизатора, если они завершатся.
* Группа - участники маршрута создаются снаружи маршрутизатора, и маршрутизатор отправляет сообщения по указанному 
пути с использованием выбора актора, не наблюдая за завершением.

Настройки для роутера могут быть определены в конфигурации или программно. Чтобы заставить актора использовать внешний 
конфигурируемый маршрутизатор, необходимо, чтобы сторонняя оболочка `FromConfig` использовалась для обозначения того, что 
актор принимает настройки маршрутизации из конфигурации. Это контрастирует с удаленным развертыванием, когда такие опоры
 маркера не нужны. Если реквизит актора НЕ завернут в `FromConfig`, он проигнорирует раздел маршрутизатора конфигурации 
 развертывания.

Вы отправляете сообщения на маршруты через роль маршрутизатора так же, как и для обычных участников, то есть через 
`ActorRef`. Актор маршрутизатора пересылает сообщения на свои маршруты без изменения исходного отправителя. Когда 
маршрут отвечает на перенаправленное сообщение, ответ будет отправлен исходному отправителю, а не игроку маршрутизатора.

>В общем, любое сообщение, отправленное маршрутизатору, будет отправлено на его маршруты, но есть несколько исключений. 

#### Pool
В следующих фрагментах кода и конфигурации показано, как создать циклический маршрутизатор, который пересылает сообщения 
на пять рабочих маршрутов. Маршруты будут созданы как дети роутера.

```yaml
akka.actor.deployment {
  /parent/router1 {
    router = round-robin-pool
    nr-of-instances = 5
  }
}
```

```scala
val router1: ActorRef =
  context.actorOf(FromConfig.props(Props[Worker]), "router1")
```

Вот тот же пример, но с конфигурацией маршрутизатора, предоставляемой программно, а не из конфигурации.

```scala
val router2: ActorRef = context.actorOf(RoundRobinPool(5).props(Props[Worker]), "router2")
```

#### Удаленные развернутые маршруты
Помимо возможности создания локальных участников в качестве маршрутов, вы можете поручить маршрутизатору развернуть 
свои созданные дети на множестве удаленных хостов. Маршруты будут развернуты круговым способом. Чтобы удаленно 
развертывать маршруты, заверните конфигурацию маршрутизатора в `RemoteRouterConfig`, добавив удаленные адреса узлов для 
развертывания. Для удаленного развертывания требуется, чтобы модуль `akka-remote` был включен в путь к классам.

```scala
import akka.actor.{ Address, AddressFromURIString }
import akka.remote.routing.RemoteRouterConfig
val addresses = Seq(
  Address("akka.tcp", "remotesys", "otherhost", 1234),
  AddressFromURIString("akka.tcp://othersys@anotherhost:1234"))
val routerRemote = system.actorOf(
  RemoteRouterConfig(RoundRobinPool(5), addresses).props(Props[Echo]))
```

#### Отправители
По умолчанию, когда маршрут отправляет сообщение, он неявно устанавливает себя как отправитель.

```scala
sender() ! x // ответы будут переданы этому актору
```

Однако для маршрутов часто бывает полезно установить маршрутизатор в качестве отправителя. Например, вы можете настроить 
маршрутизатор как отправителя, если хотите скрыть данные о маршрутах за маршрутизатором. В следующем фрагменте кода 
показано, как установить родительский маршрутизатор в качестве отправителя.

```scala
sender().tell("reply", context.parent) // ответы вернутся к родительскому
sender().!("reply")(context.parent)    // альтернативный синтаксис (остерегайтесь круглых скобок!)
```

#### Надзор
Маршрутизаторы, созданные маршрутизатором пула, будут созданы как дети маршрутизатора. Таким образом, маршрутизатор 
также является детским руководителем.

Стратегия надзора роутера может быть сконфигурирована с помощью свойства `supervisorStrategy` для пула. Если конфигурация 
не задана, маршрутизаторы по умолчанию используют стратегию «всегда эскалации». Это означает, что ошибки передаются 
диспетчеру маршрутизатора для обработки. Супервизор маршрутизатора будет решать, что делать с любыми ошибками.

Обратите внимание, что супервизор маршрутизатора будет обрабатывать ошибку как ошибку с самим маршрутизатором. Поэтому 
директива для остановки или перезапуска приведет к остановке или перезапуску маршрутизатора. Маршрутизатор, в свою 
очередь, заставит своих детей остановиться и перезапустить.

Следует отметить, что поведение перезапуска маршрутизатора было переопределено, так что перезапуск при повторном 
создании дочерних элементов по-прежнему будет содержать одинаковое количество участников в пуле.

Это означает, что если вы не указали `supervisorStrategy` маршрутизатора или его родителя, сбой в маршруте будет 
возрастать до родителя маршрутизатора, который по умолчанию перезапустит маршрутизатор, который перезапустит все 
маршруты (он использует `Escalate` и не останавливается маршрутов во время перезапуска). Причина заключается в том, что 
поведение по умолчанию ведет себя так, что добавление `.withRouter` к определению ребенка не изменяет стратегию надзора, 
применяемую к ребенку. Это может быть неэффективность, которую вы можете избежать, указав стратегию при определении 
маршрутизатора.

Настройка стратегии выполняется следующим образом:

```scala
val escalator = OneForOneStrategy() {
  case e ⇒ testActor ! e; SupervisorStrategy.Escalate
}
val router = system.actorOf(RoundRobinPool(1, supervisorStrategy = escalator).props(
  routeeProps = Props[TestActor]))
```

>Если дочерний элемент маршрутизатора пула завершается, пул пула не будет автоматически порождать нового ребенка. 
В случае, если все дочерние маршрутизаторы пула завершены, маршрутизатор прекратит свое существование, если он не 
является динамическим маршрутизатором, например. используя `resizer`.

#### Группа
Иногда, вместо того, чтобы роутер-актер создавал свои маршруты, желательно создавать маршруты отдельно и предоставлять 
их маршрутизатору для его использования. Вы можете сделать это, пройдя пути маршрутов к конфигурации маршрутизатора. 
Сообщения будут отправлены с помощью `ActorSelection` на эти пути, подстановочные знаки могут быть и будут приводить к 
той же семантике, что и явное использование `ActorSelection`.

```yaml
akka.actor.deployment {
  /parent/router3 {
    router = round-robin-group
    routees.paths = ["/user/workers/w1", "/user/workers/w2", "/user/workers/w3"]
  }
}
```

```scala
val router3: ActorRef = context.actorOf(FromConfig.props(), "router3")
```

Вот тот же пример, но с конфигурацией маршрутизатора, предоставляемой программно, а не из конфигурации.

```scala
val paths = List("/user/workers/w1", "/user/workers/w2", "/user/workers/w3")
val router4: ActorRef = context.actorOf(RoundRobinGroup(paths).props(), "router4")
```

Участники маршрута создаются извне с маршрутизатора:

```scala
system.actorOf(Props[Workers], "workers")
```
```scala
class Workers extends Actor {
  context.actorOf(Props[Worker], name = "w1")
  context.actorOf(Props[Worker], name = "w2")
  context.actorOf(Props[Worker], name = "w3")
  // ...
```

Пути могут содержать информацию о протоколах и адресах для участников, работающих на удаленных хостах. Для удаления 
требуется, чтобы модуль `akka-remote` был включен в путь к классам.

```yaml
akka.actor.deployment {
  /parent/remoteGroup {
    router = round-robin-group
    routees.paths = [
      "akka.tcp://app@10.0.0.1:2552/user/workers/w1",
      "akka.tcp://app@10.0.0.2:2552/user/workers/w1",
      "akka.tcp://app@10.0.0.3:2552/user/workers/w1"]
  }
}
```

### Использование маршрутизатора
В этом разделе мы расскажем, как создавать различные типы роутеров.

Участники роутера в этом разделе создаются из актера верхнего уровня с именем `parent`. Обратите внимание, что пути 
развертывания в конфигурации начинаются с `/parent/`, за которым следует имя роутера.

```scala
system.actorOf(Props[Parent], "parent")
```

[подробнее](https://doc.akka.io/docs/akka/current/routing.html)


_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/akka/blob/akka_starter/readme.md)