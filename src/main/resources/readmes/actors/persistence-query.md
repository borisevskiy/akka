## Запрос на сохранение (Persistence Query)

#### Зависимость
Чтобы использовать `Persistence Query`, вы должны добавить следующую зависимость в свой проект:

```sbtshell
libraryDependencies += "com.typesafe.akka" %% "akka-persistence-query" % "2.5.17"
```

### Вступление
`Akka Persistence Query` дополняет [Persistence](https://github.com/steklopod/akka/blob/akka_starter/src/main/resources/readmes/actors/persistence.md),
 предоставляя универсальный асинхронный потоковый интерфейс запросов, который могут реализовывать различные плагины 
 журналов, чтобы выявить их возможности запросов.

Наиболее типичным вариантом использования запроса на сохранение является реализация так называемой стороны запроса 
(также известной как «сторона чтения») в популярном шаблоне архитектуры CQRS - в котором письменная сторона приложения 
(например, реализована с использованием сохранения akka) полностью разделена из «стороны запроса». Сам вопрос о 
сохранении Akka напрямую не относится к стороне запроса приложения, однако он может помочь перенести данные со стороны 
записи в базу данных запроса. В очень простых сценариях `Persistence Query` может быть достаточно мощным, чтобы 
удовлетворить запросы вашего приложения, однако мы настоятельно рекомендуем (в духе CQRS) разделить стороны записи/чтения 
на отдельные хранилища данных по мере необходимости.

### Обзор дизайна
Запрос на сохранение Akka специально предназначен для того, чтобы быть очень слабо указанным API. Это делается для того, 
чтобы поддерживать предоставленные API-интерфейсы достаточно общим для каждой реализации журнала, чтобы иметь возможность 
раскрывать свои лучшие функции, например. SQL-журнал может использовать сложные SQL-запросы или если журнал может 
подписаться на прямой поток событий, также должно быть возможно выставить тот же API - типизированный поток событий.

**Каждый журнал чтения должен явно документировать поддерживаемые типы запросов**. 

Хотя `Akka Persistence Query` не предоставляет фактических реализаций `ReadJournals`, он определяет ряд предопределенных 
типов запросов для наиболее распространенных сценариев запросов, которые большинство журналов могут реализовать (однако 
они не требуются).

### Читать журналы
Чтобы выдать запросы, нужно сначала получить экземпляр `ReadJournal`. Чтение журналов осуществляется как [плагины сообщества](http://akka.io/community/#plugins-to-akka-persistence-query), 
каждый из которых нацелен на конкретное хранилище данных (например, базы данных `Cassandra` или `JDBC`). 
Например, с учетом библиотеки, которая предоставляет `akka.persistence.query.my-read-journal`, получение связанного 
журнала так же просто, как:

```scala
// получить чтение журнала по ID плагина
val readJournal = PersistenceQuery(system)
                   .readJournalFor[MyScaladslReadJournal]("akka.persistence.query.my-read-journal")

// запрос к журналу
val source: Source[EventEnvelope, NotUsed] =  readJournal.eventsByPersistenceId("user-1337", 0, Long.MaxValue)

// материализуйте поток, уничтожая события
implicit val mat = ActorMaterializer()
source.runForeach { event ⇒ println("Event: " + event) }
```

Разработчикам журнала рекомендуется указывать этот идентификатор в переменной, известной пользователю, так что к ней 
можно получить доступ через `readJournalFor[NoopJournal] (NoopJournal.identifier)`, однако это не применяется.

Чтение реализации журнала доступно в виде [плагинов сообщества](http://akka.io/community/#plugins-to-akka-persistence-query).

#### Предопределенные запросы
Запрос сохранения Akka имеет встроенный ряд интерфейсов запросов и предлагает разработчикам журнала реализовать их в 
соответствии с семантикой, описанной ниже. Важно заметить, что, хотя эти типы запросов очень распространены, журнал не 
обязан выполнять все из них, например, потому что в данном журнале такой запрос будет значительно неэффективным.

>Обратитесь к документации плагина `ReadJournal`, который вы используете для определенного списка поддерживаемых типов 
запросов. Например, плагины журнала должны документировать свои стратегии завершения потока.

Предопределенные запросы:

#### `PersistenceIdsQuery` и `CurrentPersistenceIdsQuery`
**`persistenceIds`**, который предназначен для того, чтобы пользователи могли подписаться на поток всех постоянных 
идентификаторов в системе. По умолчанию этот поток следует считать «живым» потоком, что означает, что журнал должен 
продолжать выдавать новые идентификаторы устойчивости при входе в систему:

```scala
readJournal.persistenceIds()
```

Если для вашего использования не требуется прямой поток, вы можете использовать запрос `currentPersistenceIds`:

```scala
readJournal.currentPersistenceIds()
```

#### `EventsByPersistenceIdQuery` и `CurrentEventsByPersistenceIdQuery`
**`eventsByPersistenceId`** - это запрос, эквивалентный повторному воспроизведению `PersistentActor`, однако, поскольку 
он является потоком, его можно сохранить и следить за дополнительными входящими событиями, которые сохраняются постоянным 
субъектом, идентифицированным данным `persistenceId`.

```scala
readJournal.eventsByPersistenceId("user-us-1337", fromSequenceNr = 0L, toSequenceNr = Long.MaxValue)
```

Большинство журналов должны будут вернуться к опросу, чтобы достичь этого, что обычно можно настроить с помощью свойства 
конфигурации обновления.

Если для вашего использования не требуется прямой поток, вы можете использовать запрос `currentEventsByPersistenceId`.

#### `EventsByTag` и `CurrentEventsByTag`
**`eventsByTag`** позволяет запрашивать события независимо от того, с какой устойчивостью они связаны. Этот запрос 
трудно реализовать в некоторых журналах или может потребоваться некоторая дополнительная подготовка используемого 
хранилища данных для эффективного выполнения. Цель этого запроса - разрешить запрос для всех событий, которые «помечены» 
определенным тегом. Это включает в себя прецедент для запроса всех доменных событий типа «Агрегатный корень». Пожалуйста, 
обратитесь к документации вашего плагина для чтения, чтобы узнать, поддерживается ли и как она поддерживается.

Некоторые журналы могут поддерживать тегирование событий через [Event Adapters](https://doc.akka.io/docs/akka/current/persistence.html#event-adapters),
 которые обертывают события в файле `akka.persistence.journal.Tagged` с данными тегами. Журнал может поддерживать другие 
 способы ведения тегов - опять же, как именно это реализовано, зависит от используемого журнала. Вот пример такого 
 адаптера событий тегов:

```scala
import akka.persistence.journal.WriteEventAdapter
import akka.persistence.journal.Tagged

class MyTaggingEventAdapter extends WriteEventAdapter {
  val colors = Set("green", "black", "blue")
  override def toJournal(event: Any): Any = event match {
    case s: String ⇒
      var tags = colors.foldLeft(Set.empty[String]) { (acc, c) ⇒
        if (s.contains(c)) acc + c else acc
      }
      if (tags.isEmpty) event
      else Tagged(event, tags)
    case _ ⇒ event
  }

  override def manifest(event: Any): String = ""
}
```

>Очень важно помнить, что при использовании запросов, охватывающих несколько `persistenceIds`, таких как `EventsByTag`, 
заключается в том, что порядок событий, при которых события появляются в потоке, редко гарантируется (или стабилен между 
материализацией).
Журналы могут выбирать для строгой упорядочивания событий, а затем должны четко указывать, какую гарантию на поставку, 
которую они предоставляют - например, «упорядоченные по временной отметке по возрастанию, независимо от `persistenceId`», 
легко достичь в реляционных базах данных, но может быть трудно эффективно внедряются в обычные хранилища данных с ключом.

В приведенном ниже примере мы запрашиваем все события, которые были помечены (мы предполагаем, что это было выполнено 
стороной записи с использованием [EventAdapter](https://doc.akka.io/docs/akka/current/persistence.html#event-adapters) 
или что журнал достаточно умен, чтобы он мог понять, что мы подразумеваем 
под этим тегом - например, если журнал хранит события как json, он может попытаться найти те, у которых тег поля 
установлен на это значение и т.д.).

```scala
// Предполагая, что журнал способен работать с числовыми смещениями, мы можем:
val blueThings: Source[EventEnvelope, NotUsed] =
  readJournal.eventsByTag("blue", Offset.noOffset)

// найдем 10 синих вещей::
val top10BlueThings: Future[Vector[Any]] =
  blueThings
    .map(_.event)
    .take(10) // отменяет поток запроса после извлечения 10 элементов
    .runFold(Vector.empty[Any])(_ :+ _)

// начать другой запрос с известного смещения
val furtherBlueThings = readJournal.eventsByTag("blue", offset = Sequence(10))
```

Как вы можете видеть, мы можем использовать все обычные потоковые операторы, доступные из `Streams` в результирующем 
потоке запросов, включая, например, взятие первых 10 и отмену потока. Стоит отметить, что встроенный запрос `EventsByTag`
имеет необязательно поддерживаемый параметр смещения (типа Long), который журналы могут использовать для реализации 
возобновляемых потоков. Например, журнал может использовать предложение WHERE, чтобы начать чтение, начиная с 
определенной строки, или в хранилище данных, которое может заказывать события по времени ввода, оно может обрабатывать 
Long как временную метку и выбирать только более старые события.

Если для вашего использования не требуется прямой поток, вы можете использовать запрос `currentEventsByTag`.

#### Материализованные значения запросов
Журналы могут предоставлять дополнительную информацию, связанную с запросом, путем экспонирования материализованных 
значений (`Materialized values`), которые являются характеристикой потоков, что позволяет выставлять дополнительные 
значения во время материализации.

Более сложные журналы запросов могут использовать этот метод для раскрытия информации о характере материализованного 
потока, например, если он конечен или бесконечен, строго упорядочен или не упорядочен вообще. Тип материализованного 
значения определяется как параметр второго типа возвращаемого источника, который позволяет журналам предоставлять 
пользователям свой специализированный объект запроса, как показано в примере ниже:

```scala
final case class RichEvent(tags: Set[String], payload: Any)

// плагин может предоставить:
case class QueryMetadata(deterministicOrder: Boolean, infinite: Boolean)
```

```scala
def byTagsWithMeta(tags: Set[String]): Source[RichEvent, QueryMetadata] = {
```

```scala
val query: Source[RichEvent, QueryMetadata] =
  readJournal.byTagsWithMeta(Set("red", "blue"))

query
  .mapMaterializedValue { meta ⇒
    println(s"The query is: " +
      s"заказал детерминировано: ${meta.deterministicOrder}, " +
      s"бесконечность: ${meta.infinite}")
  }
  .map { event ⇒ println(s"Полезная нагрузка: ${event.payload}") }
  .runWith(Sink.ignore)
```

[Подробнее](https://doc.akka.io/docs/akka/current/persistence-query.html)


_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/akka/blob/akka_starter/readme.md)