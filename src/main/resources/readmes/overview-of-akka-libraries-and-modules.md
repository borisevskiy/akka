## Обзор библиотек и модулей Akka

Прежде чем вникать в некоторые передовые методы для написания акторов, будет полезно просмотреть наиболее часто используемые 
библиотеки Akka. Это поможет вам начать думать о функциях, которые вы хотите использовать в своей системе. 

В `Akka` включены следующие возможности:

* Actor library

* Remoting

* Cluster

* Cluster Sharding

* Cluster Singleton

* Cluster Publish-Subscribe

* Persistence

* Distributed Data

* Streams

* HTTP

### Actor library

>добавление зависимости в `build.sbt`
```scala
    libraryDependencies += "com.typesafe.akka" %% "akka-actor" % "2.5.17"
```

Основная библиотека Akka - `akka-actor`, но акторы используются в библиотеках Akka, обеспечивая согласованную интегрированную 
модель, которая избавляет вас от индивидуального решения проблем, возникающих при параллельном или распределенном 
проектировании системы. С высоты птичьего полета акторы представляют собой парадигму программирования, которая доводит 
ее до крайности в инкапсуляции, одной из столпов ООП. В отличие от объектов, акторы инкапсулируют не только свое состояние,
 но и их исполнение. Общение с участниками не осуществляется через вызовы методов, а путем передачи сообщений. Хотя эта 
 разница может показаться незначительной, на самом деле это то, что позволяет нам избавиться от ограничений ООП, когда 
 речь заходит о параллелизме и удаленной коммуникации. Не беспокойтесь, если это описание будет слишком сложным, чтобы 
 в полной мере понять, в следующей главе мы подробно объясним акторов. На данный момент важным моментом является то, что 
 это модель, которая управляет параллелизмом и распределением на базовом уровне вместо специальных исправленных попыток 
 довести эти функции до ООП.

>Проблемы, которые решают акторы:

* Как создавать и разрабатывать высокопроизводительные параллельные приложения;

* Как обрабатывать ошибки в многопоточной среде;

* Как защитить мой проект от подводных камней параллелизма.


### Remoting

```scala
    "com.typesafe.akka" %% "akka-remote" % "2.5.17"
```
`Remoting` позволяет акторам жить на разных компьютерах, плавно обмениваться сообщениями. Хотя `Remoting` распространяется
 как артефакт JAR, он больше напоминает модуль, чем библиотеку. Вы включаете его в основном с настройкой, и у него есть 
 только несколько API. Благодаря модели актора передача удаленного и локального сообщений выглядит точно так же. Шаблоны, 
 которые вы используете в локальных системах, преобразуются непосредственно в удаленные системы. Вам редко придется использовать 
 `Remoting` напрямую, но он обеспечивает основу, на которой построена подсистема `Cluster`.

>Проблемы, которые решает `Remoting:

* Как обращаться с акторскими системами, живущими на удаленных хостах;

* Как обращаться с отдельными участниками на удаленных акторских системах;

* Как преобразовать сообщения в байты по сети;

* Как управлять низкоуровневыми сетевыми соединениями (и пересоединениями) между хостами, обнаруживать разбитые системы 
и хосты;

* Как мультиплексировать связь от несвязанного набора участников в одном и том же сетевом соединении, все прозрачно.

### Cluster

```scala
    "com.typesafe.akka" %% "akka-cluster" % "2.5.17"
```

Если у вас есть набор акторских систем, которые сотрудничают для решения некоторых бизнес-задач, то вы, вероятно, захотите 
управлять этим набором систем дисциплинированным способом. Хотя `Remoting` решает проблему адресации и взаимодействия с 
компонентами удаленных систем, `Clustering` дает вам возможность организовать их в «метасистему», связанную протоколом 
членства. В большинстве случаев вы хотите использовать модуль `Cluster` вместо прямого использования `Remoting`. 
Кластеризация предоставляет дополнительный набор сервисов поверх `Remoting`, которые необходимы большинству реальных приложений.

>Проблемы, решаемые модулем `Cluster`:

* Как поддерживать набор акторских систем (кластер), которые могут общаться друг с другом и рассматривать друг друга как 
часть кластера;

* Как безопасно внедрить новую систему в набор уже существующих членов;

* Как надежно обнаружить системы, которые временно недоступны;

* Как удалить неудавшиеся хосты / системы (или уменьшить систему), чтобы все остальные члены согласовали оставшееся 
подмножество кластера;

* Как распределить вычисления среди текущего набора членов;

* Как назначить членов кластера определенной роли, другими словами, предоставлять определенные услуги, а не другие.


### Cluster Sharding

```scala
    "com.typesafe.akka" %% "akka-cluster-sharding" % "2.5.17"
```

`Sharding` помогает решить проблему распределения множества участников среди членов кластера `Akka`. `Sharding` - это шаблон,
 который в основном используется вместе с `Persistence`, чтобы сбалансировать большой набор постоянных объектов 
 (поддерживаемых участниками) для членов кластера, а также переносить их на другие узлы, когда члены падают или уходят.

>Проблемы, решаемые модулем `Cluster Sharding`:

* Как моделировать и масштабировать большой набор объектов с состоянием на множестве систем;

* Как обеспечить правильное распределение объектов в кластере, чтобы загрузка была должным образом сбалансирована между машинами;

* Как обеспечить миграцию объектов из разбитой системы без потери состояния;

* Как обеспечить, чтобы сущность не существовала в нескольких системах одновременно и, следовательно, сохранялась последовательной.

### Cluster Singleton

```scala
    "com.typesafe.akka" %% "akka-cluster-singleton" % "2.5.17"
```

Обычный (по сути, слишком общий) случай использования в распределенных системах состоит в том, чтобы иметь единый объект, 
ответственный за задание, которое совместно используется другими членами кластера и переносится, если хост-система выходит 
из строя. Хотя это, несомненно, представляет общие узкое место для всего кластера, что ограничивает масштабирование, есть 
ситуации, в которых использование этой модели является неизбежным. `Cluster singleton` позволяет кластеру выбирать систему 
акторов, в которой будет находиться конкретный актор, в то время как другие системы могут всегда обращаться к указанной 
службе независимо от того, где она находится.

>Проблемы, решаемые модулем `Singleton`:

* Как убедиться, что во всем кластере работает только один экземпляр службы;

* Как обеспечить, чтобы служба работала, даже если система, в которой он находится, в настоящее время сбой или завершение 
работы во время процесса масштабирования;

* Как получить этот экземпляр от любого члена кластера, предполагая, что он может со временем мигрировать в другие системы.

### Cluster Publish-Subscribe

```scala
    "com.typesafe.akka" %% "akka-cluster-tools" % "2.5.17"
```

Для координации между системами часто необходимо распространять сообщения для всех или одну систему набора заинтересованных
 систем в кластере. Этот шаблон обычно называется `publish-subscribe`, и этот модуль решает эту точную проблему. Можно 
 передавать сообщения всем абонентам темы или отправлять сообщение произвольному актору, который выразил заинтересованность.

>Проблемы, решаемые модулем `Publish-Subscribe`:

* Как передавать сообщения заинтересованному набору сторон в кластере;

* Как отправить сообщение члену из заинтересованного набора сторон в кластере;

* Как подписаться и отказаться от подписки на события определенной темы в кластере.

### Persistence

```scala
    "com.typesafe.akka" %% "akka-persistence" % "2.5.17"
```

Точно так же, как объекты в ООП, акторы сохраняют свое состояние в энергозависимой памяти. Как только система будет 
отключена, изящно или из-за сбоя, все данные, которые были в памяти, будут потеряны. Настойчивость предоставляет шаблоны, 
позволяющие акторам сохранять события, которые приводят к их текущему состоянию. При запуске события могут быть воспроизведены 
для восстановления состояния объекта, размещенного актором. Поток событий может быть запрошен и передан в дополнительные 
конвейеры обработки (например, внешний кластер больших данных) или альтернативные представления (например, отчеты).

>Проблемы, решаемые модулем `Persistence`:

* Как восстановить состояние объекта / субъекта при перезапуске или сбое системы;

* Как реализовать систему [CQRS](https://msdn.microsoft.com/en-us/library/jj591573.aspx);

* Как обеспечить надежную доставку сообщений при возникновении сетевых ошибок и сбоев системы;

* Как наследовать события домена, которые привели сущность к текущему состоянию;

* Как использовать [Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html) в своем приложении для поддержки длительных процессов, пока проект продолжает развиваться.

### Distributed Data (Распределенные данные)

```scala
    "com.typesafe.akka" %% "akka-distributed-data" % "2.5.17"
```

В ситуациях, когда допустимая согласованность приемлема, можно обмениваться данными между узлами в кластере Akka и 
принимать как чтение, так и запись даже перед лицом кластерных разделов. Это может быть достигнуто с использованием  
[Conflict Free Replicated Data Types]( Conflict Free Replicated Data Types ), где записи на разных узлах могут происходить 
одновременно и впоследствии объединены в предсказуемый. Модуль `Distributed Data` предоставляет инфраструктуру для обмена 
данными и ряда полезных типов данных.

>Проблемы, решаемые модулем `Distributed Data`:

* Как принимать записи даже перед лицом кластерных разделов;

* Как обмениваться данными и одновременно обеспечивать локальный доступ на чтение и запись с низкой задержкой.

### Streams

```scala
    "com.typesafe.akka" %% "akka-stream" % "2.5.17"
```

Акторы являются фундаментальной моделью параллелизма, но существуют общие шаблоны, где их использование требует от 
пользователя повторного использования одного и того же шаблона. Очень распространенным является сценарий, в котором 
цепочка или график участников должны обрабатывать потенциально большой или бесконечный поток последовательных событий и 
правильно координировать использование ресурсов, чтобы более быстрые этапы обработки не подавляли более медленные в 
цепочке или графике. Потоки обеспечивают абстракцию более высокого уровня поверх акторов, что упрощает написание таких 
сетей обработки, обработку всех мелких деталей в фоновом режиме и создание безопасной, типизированной, сложной модели 
программирования. Потоки также являются реализацией стандарта [Reactive Streams](http://www.reactive-streams.org/), 
который позволяет интегрироваться со всеми сторонними реализациями этого стандарта.

>Проблемы, решаемые модулем `Streams`:

* Как обрабатывать потоки событий или большие массивы данных с высокой производительностью, используя параллелизм и 
ограничивать использование ресурсов;

* Как собрать многоразовые фрагменты обработки событий/данных в гибкие конвейеры;

* Как гибко подключать асинхронные службы друг к другу и иметь хорошую производительность;

* Как обеспечить или использовать совместимые с `Reactive Streams` интерфейсы для взаимодействия с сторонней библиотекой.

### HTTP

```scala
    "com.typesafe.akka" %% "akka-stream" % "2.5.17"
```

[Akka HTTP](https://doc.akka.io/docs/akka-http/current) - это отдельный модуль от Akka.

Фактически стандартом для предоставления API-интерфейсов удаленно, внутренним или внешним является [HTTP](https://ru.wikipedia.org/wiki/HTTP).
 Akka предоставляет библиотеку для создания для создания HTTP-сервисов (и обслуживающих их) и клиента, который может использоваться для 
использования других сервисов. Эти инструменты особенно подходят для потоковой передачи большого количества данных или 
событий в реальном времени путем использования базовой модели потоков Akka.

> Некоторые из проблем, решаемые модулем `HTTP`:

* Как выставлять службы системы или кластера во внешний мир с помощью API HTTP по-своему;

* Как передавать большие наборы данных в систему и из нее с использованием HTTP;

* Как передавать текущие события в систему и из нее с использованием HTTP.

### Пример использования модул;

Модули Akka легко интегрируются. Например, подумайте о большом наборе объектов бизнес-состояния, таких как документы 
или тележки для покупок, доступ к которым пользователи веб-сайта. Если вы моделируете их как осколочные объекты, используя 
Sharding and Persistence, они будут сбалансированы в кластере, который вы можете масштабировать по требованию. Они будут
доступны во время всплесков, которые поступают из рекламных кампаний или до того, как праздники будут обработаны, даже 
если некоторые системы выйдут из строя. Вы также можете взять поток событий домена в режиме реального времени с помощью 
запроса на сохранение и использовать потоки для передачи их в потоковый движок Fast Data. Затем сделайте вывод этого 
движка в виде потока, обработайте его с помощью операторов Akka Streams и выставляйте его в виде соединений веб-сокетов, 
обслуживаемых сбалансированным по нагрузке набором серверов HTTP, размещенных вашим кластером, чтобы задействовать 
инструмент бизнес-аналитики в реальном времени.

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/akka/blob/akka_starter/readme.md)