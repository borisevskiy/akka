## Часть 3: Работа с устройствами

Добавьте в свой проект следующую зависимость:

```sbtshell
    libraryDependencies += "com.typesafe.akka" %% "akka-actor" % "2.5.17"
```

### Введение

В предыдущих разделах я объяснял, как рассматривать акторские системы в целом, то есть как компоненты должны быть 
представлены, как должны быть организованы акторы в иерархии. В этой части мы рассмотрим акторов в частности, **реализовав
 актор устройства**.

_Если бы мы работали с объектами, мы бы обычно проектировали API как интерфейсы, набор абстрактных методов, который должен 
быть заполнен фактической реализацией._ В мире акторов **протоколы** заменяют интерфейсы. Хотя формализовать общие протоколы 
на языке программирования невозможно, мы можем составить их самый **базовый элемент - сообщения**. Итак, мы начнем с определения 
сообщений, которые мы хотим отправить участникам устройства.

Как правило, **сообщения попадают в категории или шаблоны**. Выявив эти шаблоны, вы обнаружите, что становится проще выбирать 
между ними и реализовывать их. _Первый пример демонстрирует шаблон сообщения запроса-ответа._

### Идентификация сообщений для устройств

Задачи актора устройства будут простыми:

* Собрать измерения температуры;

* Когда его спросят, сообщить о последней измеренной температуре.

Однако устройство может запускаться без немедленного измерения температуры. Следовательно, нам нужно учитывать случай 
отсутствия температуры. Это также позволяет нам тестировать часть запроса актора без присутствующей части записи, так как 
актор устройства может сообщить о пустом результате.

Протокол для получения текущей температуры от актора устройства прост. Актор:

1. Ожидает запроса на текущую температуру;
2. Отвечает на запрос с ответом, который:
   * содержит текущую температуру или,
   * указывает, что температура еще не доступна.

Нам нужны два сообщения: один для запроса и один для ответа. Наша первая попытка может выглядеть так:

```scala
    final case object ReadTemperature
    final case class RespondTemperature(value: Option[Double])
```

Кажется, что эти два сообщения покрывают требуемую функциональность. Однако подход, который мы выбираем, должен учитывать
 распределенный характор приложения. В то время как основной механизм является тем же самым для общения с актором на 
 локальной JVM, то с удаленным актором, нам нужно помнить следующее:

* Будут наблюдаемые различия в задержке доставки между локальными и удаленными сообщениями, поскольку такие факторы, 
как пропускная способность сетевого канала и размер сообщения также вступают в игру;

* Надежность - это проблема, потому что отправка удаленного сообщения включает в себя больше шагов, а это значит, что 
больше может пойти не так;

* Локальная передача отправляет ссылку на сообщение внутри той же JVM без каких-либо ограничений на отправку базового объекта, 
тогда как удаленный транспорт будет устанавливать ограничение на размер сообщения.

Кроме того, при отправке внутри одной JVM значительно более надежна, если актор выходит из строя из-за ошибки программиста 
при обработке сообщения, эффект такой же, как если бы удаленный сетевой запрос терпел неудачу из-за сбоя удаленного хоста 
при обработке сообщения , Несмотря на то, что в обоих случаях служба восстанавливается через некоторое время 
(актор перезапускается своим супервизором, хост перезапускается оператором или системой мониторинга), отдельные запросы 
теряются во время сбоя. Поэтому писать своих акторов, чтобы каждое сообщение могло быть потеряно, - это безопасная, 
пессимистическая ставка.

Но для дальнейшего понимания необходимости гибкости в протоколе это поможет рассмотреть заказы на доставку Akka и 
гарантии доставки сообщений. Akka обеспечивает следующее поведение для отправки сообщений:

* Доставка максимально один раз, то есть гарантированная доставка.

* Порядок сообщений поддерживается для пары отправителя, получателя.

Далее мы обсудим это поведение более подробно:

#### Доставка сообщений

Семантика доставки, предоставляемая подсистемами обмена сообщениями, обычно относится к следующим категориям:

* **Доставка максимум 1 раз (At-most-once delivery)** - каждое сообщение отправляется ноль или один раз, т.е. сообщения 
могут быть потеряны, но никогда не дублируются;

* **По меньшей мере однократная доставка (At-least-once delivery)** - потенциально допускается несколько попыток доставить 
каждое сообщение, пока, по крайней мере, одно не удастся, т.е. сообщения могут дублироваться, но никогда не теряются;

* **Ровно-разовая доставка (Exactly-once delivery)** - каждое сообщение доставляется получателю ровно один раз; 
сообщение не может быть потеряно и не дублировано.

Первое поведение, которое используется Akka, является самым дешевым и приводит к наивысшей производительности. У этого 
есть наименьшая накладная нагрузка, потому что это может быть сделано в режиме пожара и забывания, не сохраняя состояние 
на отправке или в транспортном механизме. Второй, по меньшей мере один раз, требует повторных попыток противостоять 
транспортным потерям. Это добавляет накладные расходы на сохранение состояния на отправляющем конце и наличие механизма 
подтверждения на принимающей стороне. Точная доставка по расписанию является самой дорогостоящей и приводит к наихудшей 
производительности: в дополнение к накладным расходам, добавленным по меньшей мере после доставки, для сохранения 
дублирующих поставок требуется сохранение состояния на принимающей стороне.

В акторской системе нам нужно определить точное значение гарантии - в какой момент система рассматривает доставку как выполненную:

1. Когда сообщение отправляется по сети?
2. Когда сообщение получено хостом целевого актора?
3. Когда сообщение помещается в почтовый ящик целевого участника?
4. Когда целевой агент сообщения начинает обрабатывать сообщение?
5. Когда целевой участник успешно обработал сообщение?

Большинство фреймворков и протоколов, требующих гарантированной доставки, фактически предоставляют что-то похожее на пункты 
4 и 5. Хотя это звучит разумно, **действительно ли это полезно**? Чтобы понять последствия, рассмотрите простой, практичный 
пример: _пользователь пытается разместить заказ, и мы хотим только заявить, что он успешно обработан, когда он фактически 
находится на диске в базе данных заказов._

Если мы будем полагаться на успешную обработку сообщения, актор сообщит об успехе, как только заказ будет отправлен во 
внутренний API, который должен его проверить, обработать и поместить в базу данных. К сожалению, сразу после вызова API 
может произойти любое из следующих событий:

* Хост может потерпеть крах;
* Десериаллизация может потерпеть неудачу;
* Проверка может завершиться неудачей
* База данных может быть недоступна;
* Может возникнуть ошибка программирования.

Это иллюстрирует, что **гарантия доставки** не переводится на гарантию уровня домена. Мы хотим сообщить об успехе только 
после того, как заказ был полностью обработан и сохранен. **Единственным субъектом, который может сообщить об успехе, является 
само приложение, поскольку только оно имеет какое-либо понимание требуемых гарантий домена. Никакая обобщенная структура 
не может определить специфику конкретного домена и то, что считается успешным в этой области.**

В этом конкретном примере мы хотим только отметить успех после успешной записи базы данных, когда база данных подтвердила, 
что заказ теперь безопасно сохранен. **По этим причинам Акка берет на себя ответственность за гарантии самого приложения, т.е. 
Вы должны сами их реализовать. Это дает вам полный контроль над гарантиями, которые вы хотите предоставить.** 
Теперь давайте рассмотрим сообщение, упорядочивающее Akka, чтобы упростить рассуждение о логике приложения.

#### Сортировка сообщений

В Акке для данной пары акторов сообщения, отправленные непосредственно с первого на второй, не будут получены вне порядка.
 Эта гарантия применяется только при отправке с оператором передачи непосредственно 
 в конечный пункт назначения, но не при использовании посредников.

Если:

* Актор `A1` отправляет сообщения M1, M2, M3 в `A2`.
* Актор `A3` отправляет сообщения M4, M5, M6 в `A2`.

Это означает, что для сообщений Akka:

* Если M1 доставлен, он должен быть доставлен до M2 и M3.
* Если M2 доставлен, он должен быть доставлен до M3.
* Если M4 доставлен, он должен быть доставлен до M5 и M6.
* Если M5 доставлен, он должен быть доставлен до M6.
* `A2` может видеть сообщения от `A1`, чередующиеся с сообщениями от `A3`.
* Поскольку нет гарантированной доставки, любое из сообщений может быть отброшено, то есть не достигнет A2.

Эти гарантии обеспечивают хороший баланс: получение сообщений от одного актора в порядке удобно для построения систем, 
о которых можно легко рассуждать, а с другой стороны, позволяя сообщениям от разных участников поступать чередующимися, 
обеспечивает достаточную свободу для эффективной реализации актор системы.

### Добавление гибкости в сообщения устройства

Наш первый протокол запроса был правильным, но не учитывал выполнение распределенного приложения. Если мы хотим реализовать 
повторную передачу в акторе, который запрашивает актор устройства (из-за просроченных запросов), или если мы хотим 
запросить нескольких участников, мы должны иметь возможность сопоставлять запросы и ответы. Следовательно, мы добавляем 
еще одно поле в наши сообщения, так что идентификатор может быть предоставлен реквестером (мы добавим этот код в наше 
приложение на более позднем этапе):
   
```scala
    final case class ReadTemperature(requestId: Long)
    final case class RespondTemperature(requestId: Long, value: Option[Double])
```

### Определение актора устройства и его протокол чтения

Как мы узнали в примере `AkkaQuickstart`, каждый участник определяет тип сообщений, которые он принимает. Актор нашего 
устройства несет ответственность за использование одного и того же ID-параметра для ответа на заданный запрос, который 
заставит его выглядеть следующим образом.
    
```scala
    import akka.actor.{Actor, ActorLogging, Props}
    
    object Device {
      def props(groupId: String, deviceId: String): Props = Props(new Device(groupId, deviceId))
    
      final case class ReadTemperature(requestId: Long)
      final case class RespondTemperature(requestId: Long, value: Option[Double])
    }
    
    class Device(groupId: String, deviceId: String) extends Actor with ActorLogging {
      import Device._
    
      var lastTemperatureReading: Option[Double] = None
    
      override def preStart(): Unit = log.info("Device actor {}-{} started", groupId, deviceId)
      override def postStop(): Unit = log.info("Device actor {}-{} stopped", groupId, deviceId)
    
      override def receive: Receive = {
        case ReadTemperature(id) ⇒
          sender() ! RespondTemperature(id, lastTemperatureReading)
      }
    }
```

Обратите внимание на код, который:

* Сопутствующий объект определяет, как создать актор устройства. Параметры реквизита включают идентификатор для устройства
 и группу, к которой он принадлежит, которые мы будем использовать позже;

* Сопутствующий объект включает определения сообщений, о которых мы говорили ранее;

* В классе `Device` значение `lastTemperatureReading` изначально установлено на `None`, и актор будет сообщать об этом, 
если запрашивается.

### Тестирование актора

Основываясь на простом акторе выше, мы могли бы написать простой тест. В пакете `ru.iot` в тестовом дереве вашего проекта 
добавьте следующий код в файл `DeviceSpec.scala`. (Мы используем `ScalaTest`, но любые другие тестовые фрэймворки могут 
использоваться с `Akka Testkit`).

Вы можете запустить этот тест, выполнив тест в командной строке `sbt`.

```scala
    "reply with empty reading if no temperature is known" in {
      val probe = TestProbe()
      val deviceActor = system.actorOf(Device.props("group", "device"))
    
      deviceActor.tell(Device.ReadTemperature(requestId = 42), probe.ref)
      val response = probe.expectMsgType[Device.RespondTemperature]
      response.requestId should ===(42)
      response.value should ===(None)
    }
```

Однако этот подход не учитывает, что отправитель сообщения о температуре записи никогда не может быть уверен, обработано 
ли сообщение или нет. Мы видели, что Akka не гарантирует доставку этих сообщений и оставляет их в приложении для 
предоставления уведомлений об успехах. В нашем случае мы хотели бы отправить подтверждение отправителю после того, как 
мы обновили нашу последнюю запись температуры, например. `final case class TemperatureRecorded(requestId: Long)`.
 Как и в случае температурных запросов и ответов, рекомендуется включить поле идентификатора, чтобы обеспечить максимальную гибкость.

### Актор с сообщениями чтения и записи

Соединяя протокол чтения и записи, актор устройства выглядит следующим образом:

```scala
    import akka.actor.{ Actor, ActorLogging, Props }
    
    object Device {
      def props(groupId: String, deviceId: String): Props = Props(new Device(groupId, deviceId))
    
      final case class RecordTemperature(requestId: Long, value: Double)
      final case class TemperatureRecorded(requestId: Long)
    
      final case class ReadTemperature(requestId: Long)
      final case class RespondTemperature(requestId: Long, value: Option[Double])
    }
    
    class Device(groupId: String, deviceId: String) extends Actor with ActorLogging {
      import Device._
      var lastTemperatureReading: Option[Double] = None
    
      override def preStart(): Unit = log.info("Device actor {}-{} started", groupId, deviceId)
      override def postStop(): Unit = log.info("Device actor {}-{} stopped", groupId, deviceId)
    
      override def receive: Receive = {
        case RecordTemperature(id, value) ⇒
          log.info("Recorded temperature reading {} with {}", value, id)
          lastTemperatureReading = Some(value)
          sender() ! TemperatureRecorded(id)
    
        case ReadTemperature(id) ⇒
          sender() ! RespondTemperature(id, lastTemperatureReading)
      }
    }
```

Мы также должны написать новый тестовый пример, одновременно используя функции чтения / запроса и записи / записи:

```scala
    import akka.testkit.TestProbe
    import ru.testkit.AkkaSpec
    
    class DeviceSpec extends AkkaSpec {
      "Device actor" must {
        "reply with empty reading if no temperature is known" in {
          val probe = TestProbe()
          val deviceActor = system.actorOf(Device.props("group", "device"))
    
          deviceActor.tell(Device.ReadTemperature(requestId = 42), probe.ref)
          val response = probe.expectMsgType[Device.RespondTemperature]
          response.requestId should ===(42)
          response.value should ===(None)
        }
    
        "reply with latest temperature reading" in {
          val probe = TestProbe()
          val deviceActor = system.actorOf(Device.props("group", "device"))
    
          deviceActor.tell(Device.RecordTemperature(requestId = 1, 24.0), probe.ref)
          probe.expectMsg(Device.TemperatureRecorded(requestId = 1))
    
          deviceActor.tell(Device.ReadTemperature(requestId = 2), probe.ref)
          val response1 = probe.expectMsgType[Device.RespondTemperature]
          response1.requestId should ===(2)
          response1.value should ===(Some(24.0))
    
          deviceActor.tell(Device.RecordTemperature(requestId = 3, 55.0), probe.ref)
          probe.expectMsg(Device.TemperatureRecorded(requestId = 3))
    
          deviceActor.tell(Device.ReadTemperature(requestId = 4), probe.ref)
          val response2 = probe.expectMsgType[Device.RespondTemperature]
          response2.requestId should ===(4)
          response2.value should ===(Some(55.0))
        }
    
      }
   
    }
```

_Если этот проект окажется полезным тебе - нажми на кнопочку **`★`** в правом верхнем углу._

[<= содержание](https://github.com/steklopod/akka/blob/akka_starter/readme.md)